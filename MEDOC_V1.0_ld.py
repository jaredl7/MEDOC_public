def  initialize_additive_DF_array_MEDOC_public():
    import numpy as np
    global DF_V,DF_Q
    DF_V=np.array([[[-0.09814503006414027,-0.00829083674554501,0.02069052993698899,0.022764800034716755,0.026376024825803358,0.04079061538041999]\
    ,[-0.09304533546944738,-0.01168163063259197,0.029148162211159886,0.034573952585421716,0.036962516294832264,0.04389309879451119]\
    ,[-0.10917635227208095,-0.01508296471050332,0.021012423403039278,0.033690195118149475,0.04356625287618849,0.029829597140747288]\
    ,[-0.08448688459551854,0.0010452734081126264,0.013127658435950915,0.012953705538618056,-0.029404194130851484,0.055030180399804576]\
    ,[-0.21690303214175155,-0.0048112297775041585,0.05285639369305626,0.03221913291471838,0.05672514238466199,0.107241996117071]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[0.0960264723482048,0.14624034591723908,0.18347899068707088,0.18975875712655169,0.14936689949676674,0.09615404956002349]\
    ,[-0.06467454370648426,0.013380488692223039,0.04335885350741095,0.02316539326397672,0.049903954408949965,0.05498538753463285]\
    ,[-0.05512108276442692,0.01663051907476934,0.032942793205950234,0.029777445424963897,0.042157426628694025,0.042587166017544566]\
    ,[-0.11832732948563851,-0.00594652189278002,0.05161987726427455,-0.0032819449596649397,0.02802986568478801,-0.05330800036191256]\
    ,[-0.017883702304757478,0.02456300301888289,0.03806376083390284,0.031143225951056598,0.04316622527388991,0.03861323108798072]\
    ,[-0.0874480230112806,0.0005622223046289621,0.01942881006255066,-0.014285434717318975,-0.0312269154603095,0.06646508312597733]\
    ,[-0.09989478442823643,-0.01808123925823244,0.017072070544487825,0.0348368909924136,-0.03310474356655035,0.09507777627859972]\
    ,[-0.08158971639604323,0.003750311972060806,0.021579582095461788,0.02995580604310409,0.00500911632668722,-0.01839556768577185]\
    ,[-0.08951352186020228,-0.0006698252487210704,0.024195553599692513,0.03159319892243239,0.030212308735902412,0.05633540193579425]\
    ,[-0.236836729200542,-0.017997997084072716,-0.01553659428180449,0.030141611227043254,0.042040512786275526,0.056201476460303386]\
    ,[-0.09242179483084709,-0.013124673800463844,0.01576136836717485,0.02174268842319781,0.03447444655875749,0.009438608909709427]\
    ,[-0.07935310042767338,-0.0010719297463103114,0.03344422486666974,0.030610203233417295,0.03890124193586497,0.04473450961219479]\
    ,[-0.08695017047325584,-0.005373952979996946,0.029127857638777982,0.0312603918689327,0.04934931757260941,0.0368315168559229]\
    ,[-0.05628676396346869,0.018962415116782136,0.030200837655631817,0.04260530926805834,0.04881322480499954,0.04544388691431143]\
    ,[-0.1579309119001219,-0.02341443756830642,0.037225513676135386,0.0362792660383576,0.004737830912580683,0.04319702479472116]]\
    ,[[-0.1736875245498383,-0.03212340028874131,0.0018993119947976443,0.0059849245089558765,0.02124825095580544,0.01542135737912272]\
    ,[-0.1710557565478377,-0.03364870882799501,0.006962473577143866,0.014208279143679049,0.019176229117946218,0.018666569601631332]\
    ,[-0.18704258417458502,-0.03620398638246763,0.0021258605695279216,0.00958528489738269,0.015950595123349547,0.015888493456329162]\
    ,[-0.15978519863964097,-0.015193111655213011,-0.004543537228943732,-0.005810504902595361,0.001211831711295016,-0.029637568260411744]\
    ,[-0.265794333809359,-0.01098275661415156,0.023310980280308924,0.04604403647604573,-0.004383328252121028,0.15281322208498269]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[0.028327524005790344,0.12678580626802685,0.15053243868145888,0.1396583921394307,0.10704990032049617,0.08041056791800583]\
    ,[-0.14040388012430757,-0.004634556521311273,0.021221304206803588,0.025415163643996482,0.01300114155781146,0.035960326594166314]\
    ,[-0.11180005121071279,-0.00790661654901701,0.008065269220748556,0.01915074666059384,0.013501678469567737,0.02865841453001855]\
    ,[-0.18403285574313183,-0.015268232708448258,0.01906798353026109,0.01277357309186815,-0.005488314153653567,0.06417328536697009]\
    ,[-0.05591611979451071,0.002490637524058679,0.017408220939823003,0.017456553476757463,0.019898598245154074,0.016195291585171256]\
    ,[-0.17062346145813187,-0.018482405659511855,-0.006386155406357567,-0.0059814323124224265,0.030944887598309455,-0.08044967502170272]\
    ,[-0.1965033680490634,-0.044031667092552115,0.007872091844576625,0.012051754836853036,0.018100660878122947,0.014100063508717125]\
    ,[-0.15864127590529692,-0.012387549958144464,0.0074724624621604445,0.009305376582755747,0.011997383040821622,0.019479288206484018]\
    ,[-0.15805865104866434,-0.025678890170240803,0.0056716629622748475,0.011313294883195971,0.0231028999052599,0.025783803622022983]\
    ,[-0.3365687377038947,-0.03774988730777259,-0.025653389166144812,0.0422404998983396,-0.024724320160489067,-0.042838831623705706]\
    ,[-0.16928157649557038,-0.03166840373673335,-0.0012311576526688114,0.009746434166865894,0.006601513489848894,0.02649554221267829]\
    ,[-0.1595613855219334,-0.022950366888830474,0.010269451758506987,0.017551839786707345,0.027947727012862557,0.015999523029874063]\
    ,[-0.17522506486364278,-0.030856192130948194,0.014790293555891787,0.007538631121956855,0.015682699720808956,0.031195806945032087]\
    ,[-0.11783122007918154,-0.007190406917247816,0.013019100625245444,0.020529828574650338,0.022204857375337155,0.02236469649994579]\
    ,[-0.21939902018557844,-0.0236924257889203,0.018484603045736094,-0.005867413603460225,0.014840957243556803,0.0020237262457752613]]\
    ,[[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]]\
    ,[[-0.0006560363800428431,0.017576246527726744,0.03008164293748003,0.03415531927321283,0.030141568877442886,0.044207304828451685]\
    ,[0.006982542206302393,0.025014332773102395,0.032886085087876785,0.03572446532684106,0.048716296570434164,0.033745325739614765]\
    ,[-0.007518042027014102,0.023770881049359188,0.03101304534592246,0.036380156633212375,0.043646569226534766,0.04024154617270405]\
    ,[-0.01007046276208682,0.012742062309855771,0.023814123942612335,-0.0021809941525407495,0.010467561390157747,-0.06573477481798018]\
    ,[0.055477009911087984,0.00627945480423403,0.0092874033522772,-0.038247383584260476,0.007466647906540322,0.04268048266274342]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[-0.1321694626787929,-0.0967316389078674,-0.06873179885546174,-0.016529858238667795,0.019671997748505726,0.029419251146583184]\
    ,[-0.010364462267885927,0.013790474140330963,0.026345199526713606,0.022818234394044866,0.025409162636675052,0.012760754702843317]\
    ,[0.005442484530153016,0.025787234454961675,0.03376592092627775,0.032877785177585404,0.031348968336479405,0.043241683575552595]\
    ,[-0.02251451717471522,0.007290575813393679,0.029400593000571247,0.029340306325182742,0.03981605687929736,0.01750648773562922]\
    ,[0.0166600334696883,0.03005643512105581,0.03641745659081505,0.03817866564826463,0.042348875288438774,0.041078310001161036]\
    ,[-0.00597323606546267,0.015142925079749282,0.022055801572964103,0.007399495395348531,-0.021541172512766056,0.07552783558902708]\
    ,[-0.008063015206341818,0.015665392013667137,0.022606845297376915,0.017825963721647624,0.06940144304651008,0.009221847125200112]\
    ,[-0.013793695757994474,0.009711396978727332,0.020258871518649742,-0.012595591191361784,0.024467224765768833,0.06333164148878584]\
    ,[0.006810928658946724,0.02783802048600452,0.033148777963438444,0.0351957271708956,0.03950335340840296,0.03897919554488183]\
    ,[-0.017184653241082218,0.05871433408116973,0.030341030778760117,0.05681139880223231,0.06634117688305469,0.09662211105241225]\
    ,[0.003242459770048896,0.022390925906296884,0.03127235396341395,0.03149620373316191,0.04106117199247397,0.030986738230998078]\
    ,[-0.0029020200448697936,0.01895285746039096,0.032008369025381,0.02894746133170481,0.03739628818550957,0.042540476297507034]\
    ,[-0.0033934732964372646,0.018971356384024366,0.0292200144718752,0.027318158555992473,0.03527353223490641,0.047494930505991816]\
    ,[-0.0020452791650115223,0.022734026778768082,0.03245626597561265,0.03171437996861728,0.037548846694976,0.04066331047112597]\
    ,[-0.029279333847121773,0.0075547513069324015,0.03964118638194607,0.031266639383598735,0.011548266870763664,0.08870967327908091]]\
    ,[[-0.17084210594904514,-0.022099918877378576,0.014120014237955923,0.01255769428691967,0.026583953212703074,0.01508086914077416]\
    ,[-0.15069516354151227,-0.017271791267881753,0.013818742554240177,0.025776460947306273,0.03734918248509099,0.03749059989028692]\
    ,[-0.16953746812172468,-0.02493478943963027,0.008277129893803796,0.022277924856971006,0.030544694025584632,0.02482303514003073]\
    ,[-0.171039209692462,-0.01946687683707459,-0.0074749602680714775,-0.023348622356317343,-0.05257503495583072,0.037288310594207286]\
    ,[-0.21650285796168306,-0.011581570239445858,0.033906637707397144,-0.005483527606754593,-0.050016790733475903,0.10194235048455046]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[-0.07662516120041804,0.13940191874848715,0.21611212509088626,0.30629152638941,0.23390459740311087,0.12167267060185707]\
    ,[-0.14018106245921416,0.0018208238718888312,0.01530542767703933,0.025531693374791897,0.02918652076400237,0.033180993443134514]\
    ,[-0.1030398571705276,0.00826837665424289,0.017135425858650803,0.02848090435760641,0.03280738721302972,0.02767118822745839]\
    ,[-0.18277744826286102,-0.022016125001255972,0.019320434845680724,0.022704868380946538,0.00352130636308514,-0.04920120272901054]\
    ,[-0.05074551177888,0.02043138928037861,0.02999078335203812,0.031082277613801064,0.037303725043066664,0.03535185363560578]\
    ,[-0.17133841843828002,-0.020458348940630693,-0.016589408014715888,-0.056413389743416066,-0.03451895611115501,-0.09671283790963942]\
    ,[-0.17791201755244088,-0.03257102792905086,-0.007922328089363398,0.021382457041577985,0.006235694645523211,0.07206103259101587]\
    ,[-0.17202345863873184,-0.017508965353317633,0.004866383509992529,-0.04401083967617992,0.004158337780145391,-0.12476469400782567]\
    ,[-0.14596461828626855,-0.014392467967268535,0.011380757575454856,0.0259447173353388,0.040060425921753226,0.02289681007288067]\
    ,[-0.2491078747670432,-0.03351869936540874,0.031363147841980424,0.02747909500284543,0.010956243002188969,0.05665228202486094]\
    ,[-0.16640801557942994,-0.027874538747053403,0.00043379734266717207,0.00399293616568637,0.01652422827784284,0.016853112800304597]\
    ,[-0.14642355668248966,-0.006516623643763118,0.017823607455771964,0.02637505361495418,0.031168036345400215,0.05807761918516998]\
    ,[-0.15553111788032722,-0.014889632976041199,0.018827175251755857,0.017106832380835508,-0.0003291527991291718,0.04658364918622336]\
    ,[-0.11400032152104517,0.006110822465742141,0.02408009581539319,0.030118137588815312,0.0384340040672249,0.042394350383246564]\
    ,[-0.2218388958182611,-0.030693963794283748,0.027490772302327198,-0.00823444092883456,0.003123786489651184,0.006554724627917757]]\
    ,[[-0.06954768366510868,0.030177504977789076,0.054770271364577294,0.04261030636559745,0.03775383628891438,0.05575076563937954]\
    ,[-0.055708066148441454,0.03725641633259451,0.05277781767756678,0.050113796544419206,0.04306540454092449,0.05956084128910389]\
    ,[-0.0787986979727334,0.03619307215733659,0.05236189562250809,0.05550988814525403,0.04176739806355216,0.0677442994364343]\
    ,[-0.0853426228335451,0.0280769108239566,0.048490052459715355,0.03894908998485083,0.052477352528545365,0.05047300245967379]\
    ,[0.04700648739448552,0.03935459306590028,0.047433501968440456,-0.02263925513439806,0.1191425610604626,0.22011421957512442]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[-0.3306146077056944,-0.18463624664290362,-0.12288530646194068,-0.04584689421456875,0.01855413513242482,0.030648706657669222]\
    ,[-0.09607090294139137,0.011935001221971518,0.03420555166470182,0.030355550886832124,0.042193093069604816,0.027961177914468144]\
    ,[-0.05019612964583711,0.03714754412064866,0.047726615121928224,0.041694545552436485,0.04913910317498142,0.0562924610341742]\
    ,[-0.09480370450444114,0.01879951232631937,0.04740579291844597,0.03390329629944078,0.10970039412260016,0.018237465680700865]\
    ,[-0.020860277017295384,0.042094489883172985,0.04364132984350217,0.0514679791048815,0.04804117451776813,0.05012549631127791]\
    ,[-0.07881329188054159,0.03058398532969841,0.052413373611755236,0.029208470689335093,0.013611902688318592,0.12047661263327764]\
    ,[-0.08839035468092035,0.028389191034801167,0.0513679896103843,0.01955461662590141,0.07450388335634055,0.04846708006735181]\
    ,[-0.09468332464926194,0.014729385661499006,0.04318280523427651,0.024583592299987182,0.07959910619937274,-0.03495810941190802]\
    ,[-0.04778421234029004,0.043440230076270285,0.04848710698126801,0.052152826234281725,0.05307107483319181,0.052211872090265524]\
    ,[-0.15953590511358468,0.09241466070454163,0.06451155147331174,0.10173037154073514,0.05604151973154802,0.076883009229945]\
    ,[-0.05857973226001911,0.04035072207494691,0.056966234697544714,0.043926088288897595,0.05460213058708099,0.05397138818586648]\
    ,[-0.08357920342077421,0.03092900602301457,0.04506631759431765,0.038634990717413116,0.047629581221684994,0.05477173150265985]\
    ,[-0.07947823192886266,0.030155277561817552,0.049350445192060034,0.03843069643496533,0.0523094672125382,0.025845428311250678]\
    ,[-0.07072944159839083,0.027201651739164907,0.04335906829644441,0.04064806080895663,0.04592628726211476,0.050792661897275916]\
    ,[-0.08329137203581599,0.026398779598624196,0.06347964745866509,0.048704222857452545,0.06842390576347482,0.10480425478276015]]\
    ,[[-0.06241764196708248,0.030258851929258535,0.058497951759854436,0.03543142885149094,0.055694904685946595,0.04973755035173888]\
    ,[-0.049871899316551074,0.03868122766364475,0.051551739673094725,0.04719869900017683,0.046431426368617086,0.061658814055687225]\
    ,[-0.06767352542436204,0.034069287121829196,0.05312766600416529,0.052570228616864556,0.04009483359560788,0.06964873858943778]\
    ,[-0.0759514469708133,0.027821978509968766,0.0594104641746174,0.03170396614939606,0.05504977666724973,0.10995166859727987]\
    ,[0.06306411997928503,0.056981090378274035,0.041489788159023225,0.259430698425717,0.09158564296497097,-0.016283221939314474]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
    ,[-0.3235061069678418,-0.1842539289857012,-0.12280615414625906,-0.044429593884948895,0.020936026179415687,0.03735161906539631]\
    ,[-0.08816306817279224,0.013827610542929851,0.03579976556657624,0.03628921986673164,0.03679358183660416,0.036376937040425036]\
    ,[-0.044018773965817395,0.03777359820865288,0.05337695426745953,0.042406261914143,0.0512259910133126,0.046167730710859736]\
    ,[-0.08717816826930877,0.02159139980237254,0.04266751465389509,0.05244245660732449,0.05523080239506714,0.05650872536106053]\
    ,[-0.015754064383376398,0.040656052258744614,0.04399057020102738,0.04714714651079062,0.04869226120207992,0.0548035218448261]\
    ,[-0.07032816789656965,0.03364919208313946,0.05938864713476791,0.04761186182260165,0.08641261778709591,0.1269246178151925]\
    ,[-0.07713146002135796,0.028857066131721832,0.055891628601149,0.033906344880834924,0.03614197037450594,0.11425205461784368]\
    ,[-0.08534918855170714,0.018139916957455128,0.0374870332875474,0.034780312129211184,0.07805103236546099,-0.01144277270919658]\
    ,[-0.04048455964478685,0.04434063707057383,0.050034275300582506,0.04603917028678425,0.0480787709732764,0.06796938365975187]\
    ,[-0.1668632793946712,0.07451305551296952,0.06455361020041653,0.09803899503255731,0.0875010043260986,0.05297868326911327]\
    ,[-0.048740498375005825,0.04209079981959804,0.06011331485568622,0.0508357994987634,0.04907782823721556,0.061750730256215865]\
    ,[-0.07068978756286647,0.02493631564298981,0.04914099994522264,0.03490048880350949,0.04771410986344599,0.04733895305420864]\
    ,[-0.07167569778366181,0.03181337229462032,0.051764565467234604,0.05255319173179999,0.050930784654692265,0.049469690472103346]\
    ,[-0.06220262655911074,0.026375444158202355,0.045660392521118004,0.03675975472204902,0.04715801231830443,0.049098366874776186]\
    ,[-0.07447997933624267,0.02916747879908975,0.06389228591248804,0.02170970257759925,0.1308768760056414,-0.022224698687782096]]],dtype=np.float16)
    DF_Q=np.array([[[-0.26912017526287124,-0.19790042588058968,-0.1771325119001334,-0.1390228005347286,-0.1157313592250951,-0.10623193041288091]\
         ,[-0.3560263520607516,-0.24627933025003113,-0.20934366100910642,-0.1830222389036811,-0.14392042913809658,-0.138717075048026]\
         ,[0.4256475738644047,0.372167923185914,0.252328295694633,0.2013536613799452,0.16072755318784787,0.15249780400932217]\
         ,[0.22843715557208621,0.2269313528526908,0.17840996635791126,0.1394174304403735,0.10357655822167937,0.09321639483857544]\
         ,[-0.09475537748184883,-0.19557242312043074,-0.22431237619319067,-0.17131551458749222,-0.16931225672131353,-0.1947467014079522]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]]\
        ,[[-0.13248987068156245,-0.10049503323340414,-0.08685052124104743,-0.0701251457833387,-0.05702023922070306,-0.050942501573915534]\
         ,[-0.17017971064212944,-0.1253152356448843,-0.10228366950929935,-0.08397203855373263,-0.07077990144669889,-0.058161752283569616]\
         ,[0.20775097292477857,0.1654398880690938,0.1109290835441011,0.08640010633109754,0.07202897414994697,0.06512582577626504]\
         ,[0.10843464777552216,0.09739262094715187,0.07512217833872348,0.06024057868295137,0.054960462708227624,
           0.049159700886994465]\
         ,[-0.0540502395024895,-0.1084284349040225,-0.10078772557805978,-0.08528817049496785,-0.06503185730851604,
           -0.07861169364041086]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]]\
        ,[[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]]\
        ,[[0.17121877608402247,0.17594084065247703,0.12904059170967974,0.10599129686565438,0.0943658131688274,0.08009514546801189]\
         ,[0.22150694409377722,0.21535255584026441,0.159419594251915,0.12981785696298773,0.1091688918983498,0.09918833660533939]\
         ,[-0.18949274939405808,-0.14328125208896705,-0.13308323983500342,-0.10907394655331742,-0.09240760246281003,-0.08130748156420634]\
         ,[-0.12189804277217274,-0.08684060560503566,-0.08147177646216318,-0.061704775073613716,-0.05818944513703821,-0.03908642889654734]\
         ,[0.0901457700763897,0.18835106928036163,0.14681904386655734,0.14354934675687644,0.1362350484771623,0.17465564751635806]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]]\
        ,[[-0.07645991225335493,-0.12870699114633158,-0.134525810533965,-0.10662665665725732,-0.08830409119430149,-0.07816545475323736]\
         ,[-0.10317973252714768,-0.16529233106043975,-0.1458598903772544,-0.12974338865199825,-0.11340577364567742,-0.10199699387084803]\
         ,[0.17147809499398675,0.28614938533479006,0.2024521716185936,0.1628948550877939,0.1379793587864573,0.12891520715142293]\
         ,[0.09516414231334615,0.1802548822952621,0.13379804760658265,0.13001112605475074,0.1278112177766325,0.10176741009077647]\
         ,[-0.0063066501821508305,-0.11717161716288614,-0.15125766498204232,-0.11602402373209846,-0.10881237599290189,-0.08702408889399628]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]]\
        ,[[0.324381869187757,0.2896563269057624,0.21037396198031996,0.16785162077403384,0.15061781758824555,0.12587627126945658]\
         ,[0.4436283912859322,0.37054832958760164,0.2602175109665942,0.2076770991050208,0.17872218702103043,0.15183733805515598]\
         ,[-0.39755021304844146,-0.2791305921075633,-0.24608355614259247,-0.19942038873986354,-0.16606973931225189,-0.14613821155689652]\
         ,[-0.23051190847571815,-0.1665060086739995,-0.15035870954979552,-0.12817908241645828,-0.11366588399840559,-0.08828327497847531]\
         ,[0.1617488660702995,0.29542855228415854,0.23544614440777636,0.22903045500858785,0.23155974983657546,0.4235103664889902]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]]\
        ,[[0.3293775540187506,0.2913838324984375,0.21159625457985348,0.17397836516386642,0.14959887418322163,0.13085586119282838]\
         ,[0.4546388456822364,0.3717559299691354,0.2684538320174004,0.21535473636227676,0.17999577597819516,0.15832215012571763]\
         ,[-0.4007088436796262,-0.28065196046897967,-0.25069862782592517,-0.20252049317423879,-0.1622791413840075,-0.14624337458185724]\
         ,[-0.23337398224807474,-0.16983815270401478,-0.15930132103271072,-0.12233479968121273,-0.11269969693784955,-0.10376378536059733]\
         ,[0.15723558477489155,0.29073213834403167,0.23113927194876213,0.19725037930799214,0.22571642137322856,0.2932908418138935]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]\
         ,[float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN'),float('NaN')]]],dtype=np.float16)
def initialize_additive_DF_array(database_suffix):
    global DF_V,DF_Q,DU_V,DU_Q
    AA_type=['E','D','H','K','Y','8','9','R','C','A','F','G','L','I','M','N','P','Q','T','V','S','W']
    AA_sign=[-1,-1,1,1,-1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    q_scale=[0.39555,0.135366,float('NaN'),float('NaN'),float('NaN'),0.293,0.293]
    V_scale=[0.408735,0.30765,float('NaN'),float('NaN'),float('NaN'),0.3809,0.3809]
    q_offset=[0.0,0.00,float('NaN'),float('NaN'),float('NaN'),0.00,0.00]
    V_offset=[0.0461475 ,0.0221508,float('NaN'),float('NaN'),float('NaN'),0.054205 ,0.054205]
    T_fact_spe=[1.,1.,1.,1.,1.,1.,1.]
    include=[]
    T_fact=1.
    for i in range(len(q_scale)):
        if math.isnan(q_scale[i]):
            include+=[False]
        else :
            include+=[True]
    for i in range(len(q_scale)):
        if math.isnan(q_scale[i]):
            q_scale[i]=np.mean(q_scale,where=include)
            V_scale[i]=np.mean(V_scale,where=include)
            q_offset[i]=np.mean(q_offset,where=include)
            V_offset[i]=np.mean(V_offset,where=include)
    max_neigh=6
    DF_V=np.array([[[float('NaN') for l in range(max_neigh)] for k in range(len(AA_type))] for i in range(0,7)])
    DU_V=np.array([[[float('NaN') for l in range(max_neigh)] for k in range(len(AA_type))] for i in range(0,7)])
    for i in range(max_neigh):
        for a0 in range(0,7):  
            try:
                if AA_type[a0]!='R':
                    temp_AA=AA_type[a0]
                    try:
                        data_U=read_file(
                            './Prediction_params/MEAN_FIELD'+database_suffix+'/VOLUME/Prediction_parameters/U/'+temp_AA+'_'+str(
                                i+1)+'.txt',silent=True)
                        data_F=read_file(
                            './Prediction_params/MEAN_FIELD'+database_suffix+'/VOLUME/Prediction_parameters/F/'+temp_AA+'_'+str(
                                i+1)+'.txt',silent=True)
                    except:
                        None
            except:
                continue
            for a1 in range(len(data_F)):
                for a2 in range(len(AA_type)):
                    if data_F[a1][0].upper()==AA_type[a2]:
                        DF_V[a0,a2,i]=float(data_F[a1][1])
                        DU_V[a0,a2,i]=float(data_U[a1][1])
    DF_Q=np.array([[[float('NaN') for l in range(0,max_neigh)] for k in range(len(AA_type))] for i in range(0,7)])
    DU_Q=np.array([[[float('NaN') for l in range(0,max_neigh)] for k in range(len(AA_type))] for i in range(0,7)])
    for i in range(max_neigh):
        for a0 in range(0,7):  
            try:
                if AA_type[a0]!='R':
                    temp_AA=AA_type[a0]
                    try:
                        data_U=read_file(
                            './Prediction_params/MEAN_FIELD'+database_suffix+'/CHARGE/Prediction_parameters/U/'+temp_AA+'_'+str(
                                i+1)+'.txt',silent=True)
                        data_F=read_file(
                            './Prediction_params/MEAN_FIELD'+database_suffix+'/CHARGE/Prediction_parameters/F/'+temp_AA+'_'+str(
                                i+1)+'.txt',silent=True)
                    except:
                        None
            except:
                continue
            for a1 in range(len(data_F)):
                for a2 in range(len(AA_type)):
                    if data_F[a1][0].upper()==AA_type[a2]:
                        DF_Q[a0,a2,i]=float(data_F[a1][1])
                        DU_Q[a0,a2,i]=float(data_U[a1][1])
    for a0 in range(0,7):
        DF_Q[a0]=T_fact*T_fact_spe[a0]*(DF_Q[a0]*q_scale[a0]+q_offset[a0]*AA_sign[a0])
        DF_V[a0]=T_fact*T_fact_spe[a0]*(DF_V[a0]*V_scale[a0]+V_offset[a0])
def read_file(file_name,silent=False,split='') :
    data=load_file(file_name,silent=silent)
    len1=len(data)
    arr=[[] for i in range(len1)]
    for i in range(len1):
        if split!='':
            temp=data[i].split(split)
        else : 
            temp=data[i].split()
        arr[i]+=temp
    return arr
def load_file(file_name,silent=False):
    try :
        with open(file_name,'r') as f :
            data=f.readlines()
            f.close()
    except :
        if silent==False:
            print("Could not open "+file_name)
    return data
def convert_AA_1_to_3(seq,mode=1) :
    dic={   "A" : "ALA",
            "C" : "CYS",
            "D" : "ASP",
            "d" : "ASH",
            "E" : "GLU",
            "e" : "GLH",
            "F" : "PHE",
            "G" : "GLY",
            "H" : "HIP",
            "h" : "HID",
            "8" : "HEX",
            "9" : "HDX",
            "I" : "ILE",
            "K" : "LYS",
            "k" : "LYD",
            "L" : "LEU",
            "M" : "MET",
            "N" : "ASN",
            "P" : "PRO",
            "Q" : "GLN",
            "R" : "ARG",
            "S" : "SER",
            "T" : "THR",
            "V" : "VAL",
            "W" : "TRP",
            "y" : "TYR",
            "Y" : "TYO",
            "z" : "NME",
            "_" : ""}
    if mode==1:
        W=''
        for i in range(len(seq)):
            try : 
                W+=dic[seq[i]]+"\n"
            except : 
                print("Could not find "+seq[i]+", exiting.")
                exit(1)
    if mode==2:
        W=[]
        for i in range(len(seq)):
            try :
                W+=[dic[seq[i]]]
            except :
                print("Could not find "+seq[i]+", exiting.")
                exit(1)
    return W
def convert_AA_3_to_1_letter(input_arr,silent=False):
    dico = {"ALA" : "A",
            "CYS" : "C",
            "ASP" : "D",
            "ASH" : "d",
            "ASX" : "D",
            "GLU" : "E",
            "GLH" : "e",
            "GLX" : "E",
            "PHE" : "F",
            "GLY" : "G",
            "HIS" : "H",
            "HID" : "h",
            "HIE" : "h",
            "HIP" : "H",
            "HIX" : "H",
            "HEX" : "8",
            "HDX" : "9",
            "ILE" : "I",
            "LYS" : "K",
            "LYD" : "k",
            "LYX" : "K",
            "LEU" : "L",
            "MET" : "M",
            "ASN" : "N",
            "PRO" : "P",
            "GLN" : "Q", 
            "SER" : "S",
            "TYR" : "y",
            "TYO" : "Y",
            "TYX" : "Y",
            "THR" : "T",
            "VAL" : "V",
            "TRP" : "W",
            "ACE" : "z",
            "ARG" : "R", 
            "NME" : "z"}
    output_arr=[]
    for i in range(len(input_arr)):
        try :         
            output_arr+=[dico[input_arr[i]]]
        except : 
            if not silent:
                print("Did not convert "+str(input_arr[i]))
    return output_arr
def read_sequence(seq_3,list_res):
    pos_res,neg_res,base_charge,arg_res,raw_seq,seq_data_q,seq_data_id,seq_id_reduced,map,new_W=HSQ_internal_sequence_create(
        seq_3,list_res)
    titrable_residue_indexes=[]
    if titrable_residue_indexes==[]:
        list_res=np.array([i for i in range(len(seq_3))])
    else:
        list_res=np.array([titrable_residue_indexes[i] for i in range(len(titrable_residue_indexes))])
    if titrable_residue_indexes==[]:
        ind=0
        sites_num=neg_res+pos_res-arg_res
        titrable_residue_indexes=np.zeros((sites_num),dtype=int)
        for i in range(len(seq_data_q)):
            if seq_data_q[i]!=0:
                titrable_residue_indexes[ind]=i
                ind+=1
    else:
        sites_num=len(titrable_residue_indexes)
        titrable_residue_indexes=np.array(titrable_residue_indexes)
    pos_res,neg_res,base_charge,arg_res,raw_seq,seq_data_q,seq_data_id,seq_id_reduced,map,new_W=HSQ_internal_sequence_create(seq_3,list_res)
    return sites_num,titrable_residue_indexes,pos_res,neg_res,base_charge,arg_res,raw_seq,seq_data_q,seq_data_id,seq_id_reduced,map,new_W
def HSQ_internal_sequence_create(seq,list_res,no_write=False):
    data=seq
    new_W=''
    pos_res=0
    neg_res=0
    base_charge=0 
    arg_res=0
    seq_data_q=[]
    seq_data_id=[]
    raw_seq=[]
    raw_seq_2=[]
    map=[]
    for i in range(len(data)) :
        line=data[i]
        do_it=find_ind(i,list_res)
        raw_seq_2+=[line]
        if (line=="GLU" or line=="GLH"  or line=="GLX") and do_it==True :
            new_W+='GLX\n'
            raw_seq+=['GLX']
            neg_res+=1
            seq_data_id+=[0]
            seq_data_q+=[-1]
        elif (line=="ASP" or line=="ASH"  or line=="ASX") and do_it==True :
            new_W+='ASX\n'
            raw_seq+=['ASX']
            neg_res+=1
            seq_data_id+=[2]
            seq_data_q+=[-1]
        elif (line=="LYD" or line=="LYS" or line=="LYX") and do_it==True :
            new_W+='LYX\n'
            raw_seq+=['LYX']
            pos_res+=1
            seq_data_q+=[1]
            seq_data_id+=[1]
        elif line=="ARG" :
            new_W+='ARG\n'
            raw_seq+=['ARG']
            pos_res+=1
            arg_res+=1
            seq_data_q+=[0] 
            seq_data_id+=[float('NaN')]
        elif (line=="TYX" or line=="TYR" or line=="TYO") and do_it==True :
            new_W+='TYX\n'
            raw_seq+=['TYX']
            neg_res+=1
            seq_data_q+=[-1]
            seq_data_id+=[3]
        elif (line=="SXP" or line=="S1P" or line=="S2P") and do_it==True :
            new_W+='SXP\n'
            raw_seq+=['SXP']
            neg_res+=1
            base_charge+=-1
            seq_data_q+=[-1]
            seq_data_id+=[4]
        elif (line=="TXP" or line=="T1P" or line=="T2P") and do_it==True :
            new_W+='TXP\n'
            raw_seq+=['TXP']
            neg_res+=1
            base_charge+=-1
            seq_data_q+=[-1]
            seq_data_id+=[5]
        elif (line=="YXP" or line=="Y1P" or line=="Y2P") and do_it==True :
            new_W+='YXP\n'
            raw_seq+=['YXP']
            neg_res+=1
            base_charge+=-1
            seq_data_q+=[-1]
            seq_data_id+=[6]
        elif (line=="HIE" or line=="HID" or line=="HIS" or line=="HEX" or line=="HDX" or line=="HIP" or line=="HIX") and do_it==True :
            new_W+='HIX\n'
            raw_seq+=['HIX']
            pos_res+=1
            seq_data_q+=[1]
            seq_data_id+=[9]
        elif do_it==False and (line=="HIS" or line=="LYS"):
            new_W+=line+'\n'
            seq_data_q+=[0]
            seq_data_id+=[float('NaN')]
            raw_seq+=[line] 
            base_charge+=1
        elif do_it==False and (line=="ASP" or line=="GLU" or line=="TYO"):
            new_W+=line+'\n'
            seq_data_q+=[0]
            seq_data_id+=[float('NaN')]
            base_charge+=-1
            raw_seq+=[line]
        elif line!="END" :
            if line!="NA+" and line!="CL-" and line!="CLX" and line!="NAX" :
                raw_seq+=[line]
            new_W+=line+'\n'
            seq_data_q+=[0]
            seq_data_id+=[float('NaN')] 
        if seq_data_q[-1]!=0 and line!="END":
            map+=[i]  
    if no_write==False :
        write_file('seq_hsq.in',new_W)
    seq_id_reduced=[]
    for i in range(len(seq_data_id)):
        if math.isnan(seq_data_id[i])==False :
            seq_id_reduced+=[seq_data_id[i]]
    return pos_res,neg_res,base_charge,arg_res,raw_seq,seq_data_q,seq_data_id,seq_id_reduced,map,new_W
def find_ind(ind,arr) :
    for i in range(len(arr)):
        if arr[i]==ind :
            return True
    return False
def get_ref_pkas(mode,FF='OPLS',DF_only=True,version=-1,silent=True,suffix='') :
    if version==-1 :
        try :
            version=read_file('/project/fava/work/martinfossat/pKa_Calc/ALL_MDCP/'+str(FF)+'/ACE-GXG-NME/Latest.inf')[0][1]
        except :
            print("Could not read info on the last model compound free energy")
            version=str(-1)
    else :
        version=str(version)
    seq_ref_arr=['GLX','LYX','ASX','TYX','SXP','TXP','YXP','HDX','HEX','HIX']
    ref_notation=[['E','e'],['K','k'],['D','d'],['Y','y'],['U','u'],['X','x'],['Z','z'],['H','9'],['H','8'],['H','h']]
    factor=[1,-1,1,1,1,1,1,-1,-1,-1]
    ref=[]
    base='/project/fava/work/martinfossat/pKa_Calc/ALL_MDCP/'+str(FF)+'/ACE-GXG-NME/298K_50mMNaCl_'+version+suffix+'/'
    for i in range(len(seq_ref_arr)):
        try : 
            ref+=[float(read_key_file(base+str(seq_ref_arr[i])+'/0.05/_Analysis/Parameters.txt',['offset'],silent=silent)[0])] 
        except :
            if not silent : 
                print("Could not get the offset from the model compounds for "+seq_ref_arr[i])
            ref+=[0.]
    if mode==1 :     
        pKa_ref_arr=[4.34,10.34,3.86,9.76,5.96,6.3,5.96,7.15,6.55,6.45] 
        folders=[base+'GLX/0.05/_Analysis/Output.txt',\
        base+'LYX/0.05/_Analysis/Output.txt',\
        base+'ASX/0.05/_Analysis/Output.txt',
        base+'TYX/0.05/_Analysis/Output.txt',
        base+'SXP/0.05/_Analysis/Output.txt',
        base+'TXP/0.05/_Analysis/Output.txt',
        base+'YXP/0.05/_Analysis/Output.txt',
        base+'HDX/0.05/_Analysis/Output.txt',
        base+'HEX/0.05/_Analysis/Output.txt']
        DF_ref=[]
        DF_ref_err=[] 
        DS_ref=[]
        DS_ref_err=[]
        DU_ref=[]
        DU_ref_err=[]
        for i in range(len(folders)):
            try : 
                data=read_file(folders[i],silent=True)        
                DF_ref+=[float(data[-2][-1])]  
                DF_ref_err+=[float(data[-1][-1])]
                DS_ref+=[float(data[-6][-1])]  
                DS_ref_err+=[float(data[-5][-1])]
                DU_ref+=[float(data[-4][-1])]  
                DU_ref_err+=[float(data[-3][-1])]
            except : 
                DF_ref+=[float('NaN')]
                DF_ref_err+=[float('NaN')]
                DS_ref+=[float('NaN')]
                DS_ref_err+=[float('NaN')]
                DU_ref+=[float('NaN')]
                DU_ref_err+=[float('NaN')]
                if not silent : 
                    print("!!!!!!!!!!!!!!!!!!!!!!!!!!! No model compound pka value !!!!!!!!!!!!!!!!!!!!!!!!")
                    print("File is not found or is invalid : ",folders[i])
    elif mode==2 :
        print("! You should proably use mode 1 instead of mode 2 !")
        pKa_ref_arr=[4.25,10.28,3.65]
        base='/work/mfossat/pKa_Calc/ALL_MDCP/'
        folders=[base+'GLX/0.05/_Analysis/Output.txt',\
        base+'LYX/0.05/_Analysis/Output.txt',\
        base+'ASX/0.05/_Analysis/Output.txt']
        DF_ref=[]
        DF_ref_err=[]
        for i in range(len(folders)):
            data=read_file(folders[i])
            DF_ref+=[float(data[-2][-1])]
            DF_ref_err+=[float(data[-1][-1])]
    else :
        print("Only modes 1 and 2 are available")
    if DF_only==True:
        out=[seq_ref_arr,ref_notation,DF_ref,DF_ref_err,folders,factor,pKa_ref_arr,ref]
    else :
        out=[seq_ref_arr,ref_notation,DF_ref,DF_ref_err,folders,factor,pKa_ref_arr,ref,DS_ref,DS_ref_err,DU_ref,DU_ref_err]    
    return out
def read_key_file(key_file,pattern,silent=True):
    found_it=[0 for i in range(len(pattern))]
    data=load_file(key_file,silent=True)
    out=[]
    if type(pattern)==type([]) :
        W=''
        val=''
        for i in range(len(data)) :
            if len(data[i].split())>0:
                found=False
                for g in range(len(pattern)) :
                    if data[i].split()[0]==str(pattern[g]) :
                        found=True
                        found_it[g]=1
                        break
                if found==True:
                    if silent==False : 
                        print(pattern[g]," is ",data[i].split()[1])
                    out+=[data[i].split()[1]]                    
    return out             
def get_ref_pkas_MEDOC_public() :
    refs=[['GLX','LYX','ASX','TYX','SXP','TXP','YXP','HDX','HEX','HIX'],
     [['E','e'],['K','k'],['D','d'],['Y','y'],['U','u'],['X','x'],['Z','z'],['H','9'],['H','8'],['H','h']],
     ['NaN','NaN','NaN','NaN','NaN','NaN','NaN','NaN','NaN'],['NaN','NaN','NaN','NaN','NaN','NaN','NaN','NaN','NaN'],
     ['','','','','','','','',''],[1,-1,1,1,1,1,1,-1,-1,-1],[4.34,10.34,3.86,9.76,5.96,6.3,5.96,7.15,6.55,6.45],
     [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],['NaN','NaN','NaN','NaN','NaN','NaN','NaN','NaN','NaN'],
     ['NaN','NaN','NaN','NaN','NaN','NaN','NaN','NaN','NaN'],['NaN','NaN','NaN','NaN','NaN','NaN','NaN','NaN','NaN'],
     ['NaN','NaN','NaN','NaN','NaN','NaN','NaN','NaN','NaN']]
    return refs
def get_base_contexts(map,neigh,seq_1,seq_data_q):
    contexts=[]
    states=[]
    for i in range(len(map)):
        tmp=''
        tmp2=[]
        for j in range(-neigh,neigh+1):
            if map[i]+j>=1 and map[i]+j<len(seq_1)-1:
                tmp+=seq_1[map[i]+j]
                tmp2+=[seq_data_q[map[i]+j]]
            else :
                tmp+='_'
                tmp2+=[float('nan')]
        contexts+=[tmp]
        states+=[tmp2]
    return contexts,states
def get_all_contexts(contexts,states,neigh,refs,unshifted,reverse,penta,additive,T,base_rep,reduced):
    import itertools
    missing_pat=False
    p=0
    pat_seq=[[] for i in range(len(contexts))]
    pat_ste=[[] for i in range(len(contexts))]
    pat_E=[[] for i in range(len(contexts))]
    for i in range(len(contexts)):
        count=0
        new_seq=''
        titratable_pre=[]
        for j in range(neigh):
            if contexts[i][j]=='E' or contexts[i][j]=='K' or contexts[i][j]=='H' or contexts[i][j]=='D' or contexts[i][j].upper()=='Y':
                titratable_pre+=[1]
            else :
                titratable_pre+=[0]
        titratable_post=[]
        for j in range(neigh+1,neigh*2+1):
            if contexts[i][j]=='E' or contexts[i][j]=='K' or contexts[i][j]=='H' or contexts[i][j]=='D' or contexts[i][j].upper()=='Y':
                titratable_post+=[1]
            else :
                titratable_post+=[0]
        for j in range(neigh):
            if states[i][j]==-1 or states[i][j]==1 :
                count+=1
        for curr in itertools.product([1,0],repeat=count):
            tmp=''
            new_seq=''
            offset=0
            txt_ste=''
            h=0
            for k in range(len(titratable_pre)):
                if titratable_pre[k]==1 :
                    if contexts[i][k]=='E' or contexts[i][k]=='D' or contexts[i][k].upper()=='Y':
                        if curr[h]==0:
                            tmp+=contexts[i][k].upper()
                        elif curr[h]==1:
                            tmp+=contexts[i][k].lower()
                    elif contexts[i][k]=='K' or contexts[i][k]=='H' :
                        if curr[h]==1:
                            tmp+=contexts[i][k].upper()
                        elif curr[h]==0:
                            tmp+=contexts[i][k].lower()
                    txt_ste+=str(curr[h])
                    h+=1
                else :
                    txt_ste+='1'
                    tmp+=contexts[i][k]
            new_seq+=tmp
            new_seq+=contexts[i][neigh].upper()
            for k in range(neigh+1,neigh*2+1):
                if contexts[i][k]=='E' or contexts[i][k]=='D' or contexts[i][k].upper()=='Y':
                    new_seq+=contexts[i][k].lower()
                elif contexts[i][k]=='K' or contexts[i][k]=='H' :
                    new_seq+=contexts[i][k].upper()
                else :
                    new_seq+=contexts[i][k]
            pat_ste[i]+=[txt_ste]
            pat_seq[i]+=[new_seq]
            if unshifted==True :
                for j in range(len(refs[1])):
                    if refs[1][j][1].upper()==new_seq[neigh].upper() :
                        break
                F_mdcp_expt=R*T*np.log(10**(refs[6][j]))
                if reverse==False:
                    pat_E[i]+=[-(F_mdcp_expt)]
                else :
                    pat_E[i]+=[F_mdcp_expt]
                continue
            else :
                if new_seq[neigh]=='H':
                    He_seq=''
                    Hd_seq=''
                    for l in range(2*neigh+1):
                        if l==neigh:
                            He_seq+='8'
                            Hd_seq+='9'
                        else :
                            He_seq+=new_seq[l]
                            Hd_seq+=new_seq[l]
                    out_e=get_pattern_energy_from_database(He_seq,refs,reverse,penta,additive,T,base_rep,neigh,silent=True,reduced=reduced)
                    out_d=get_pattern_energy_from_database(Hd_seq,refs,reverse,penta,additive,T,base_rep,neigh,silent=True,reduced=reduced)
                    if out_e==None or out_d==None :
                        missing_pat=True
                        continue
                    else :
                        F_pat_e,F_pat_err,F_mdcp_e,S_pat,S_mdcp,U_pat,U_mdcp,offset_pat_e,mdcp_offset_e,U_mdcp_expt,S_mdcp_expt,sign,F_mdcp_expt_e,T_pat=out_e
                        F_pat_d,F_pat_err,F_mdcp_d,S_pat,S_mdcp,U_pat,U_mdcp,offset_pat_d,mdcp_offset_d,U_mdcp_expt,S_mdcp_expt,sign,F_mdcp_expt_d,T_pat=out_d
                else :
                    out=get_pattern_energy_from_database(new_seq,refs,reverse,penta,additive,T,base_rep,neigh,silent=True,reduced=reduced)
                    if out==None :
                        missing_pat=True
                        continue
                    else :
                        F_pat,F_pat_err,F_mdcp,S_pat,S_mdcp,U_pat,U_mdcp,offset_pat,mdcp_offset,U_mdcp_expt,S_mdcp_expt,sign,F_mdcp_expt,T_pat=out
            if reverse==False:
                sign2=-1
            else :
                sign2=1
            if new_seq[neigh]=='H':
                pat_E[i]+=[get_G_sum([sign2*(F_mdcp_expt_e-sign*((F_pat_e-offset_pat_e)-(F_mdcp_e-mdcp_offset_e))),sign2*(F_mdcp_expt_d-sign*((F_pat_d-offset_pat_d)-(F_mdcp_e-mdcp_offset_e)))],T)]
            else :
                pat_E[i]+=[sign2*(F_mdcp_expt-sign*((F_pat-offset_pat)-(F_mdcp-mdcp_offset)))]
        pat_ste[i]=np.array(pat_ste[i])
    if missing_pat==False:
        for i in range(len(pat_E)):
            if math.isnan(np.sum(pat_E[i])):
                missing_pat=True
                break
    if (missing_pat):
        print("Some pattern free energy are missing from the database.")
        quit()
    return pat_E,pat_ste,pat_seq
def get_pattern_energy_from_database(pattern,refs,reverse,penta,additive,T,data_dir,neigh,silent=True,reduced=True,unshifted=True,ent_corr=False):
    import os
    found=False
    for j in range(len(refs[1])):
        if refs[1][j][1].upper()==pattern[neigh].upper()  :
            found=True
            break
    if found==False :
        print(pattern[neigh])
        input("This should not happen")
    sign,sign2=check_sign(pattern[neigh],refs,reverse)
    F_mdcp_expt=R*T*np.log(10**(refs[6][j]))
    good=0
    tot=0
    if penta==True :
        mdcp_offset=refs[7][j] 
        F_mdcp=refs[2][j]
        F_mdcp_err=refs[3][j]
        S_mdcp=refs[8][j]
        U_mdcp=refs[10][j]
        S_mdcp_expt=(S_mdcp/F_mdcp)*F_mdcp_expt
        U_mdcp_expt=(U_mdcp/F_mdcp)*F_mdcp_expt
        temp=convert_pattern_to_simplified(pattern,neigh)
        if additive==False :
            try :  
                dirs=os.listdir(data_dir+'/'+temp)
                if reduced==False : 
                    try : 
                        dirs_dum=os.listdir(data_dir+'/'+temp+'/'+pattern)
                    except : 
                        print("Did not find exact peptide ", pattern)
                        not_found=True  
                        setup_motif_database_sequence(temp,pattern,data_dir)
                        return None 
            except : 
                print("Did not find peptide ", temp)
                not_found=True  
                setup_motif_database_sequence(temp,pattern,data_dir)
                return None 
        good=0
        temp_pat=''
        for l in range(len(pattern)):
            if l==neigh :
                temp_pat+=pattern[l].upper()
            else :
                temp_pat+=pattern[l]
        for l in range(len(dirs)): 
            if dirs[l]==temp_pat : 
                dups=os.listdir(data_dir+'/'+temp+'/'+dirs[l])
                F_pat_err=0
                F_pat=0
                S_pat_err=0
                S_pat=0
                U_pat=0
                U_pat_err=0
                temp_vals=[]
                tot=0
                for n in range(len(dups)):
                    if os.path.isdir(data_dir+'/'+temp+'/'+dirs[l]+'/'+dups[n]):
                        try :
                            tmp=read_file(data_dir+'/'+temp+'/'+dirs[l]+'/'+dups[n]+'/_Analysis/Output.txt',silent=True)
                            F_pat_err+=float(tmp[-1][-1])**2
                            F_pat+=float(tmp[-2][-1])
                            S_pat_err+=float(tmp[-5][-1])**2
                            S_pat+=float(tmp[-6][-1])
                            U_pat_err+=float(tmp[-3][-1])**2
                            U_pat+=float(tmp[-4][-1])
                            good+=1
                            tot+=1
                            temp_vals+=[float(tmp[-2][-1])]
                        except :
                            continue
                if tot!=0 :
                    if tot==1 :
                        print('!!!!!!!!Warning!!!!!!!')
                        print(temp+'/'+dirs[l]+' does not have any duplicates. This could result in undetected bad free energy being used')
                    for k in range(len(temp_vals)): 
                        if abs(np.mean(temp_vals)-temp_vals[k])>0.05:
                            print(temp+'/'+dirs[l]+' Has at least one outlier') 
                        F_pat=F_pat/tot
                        F_pat_err=np.sqrt(F_pat_err)
                        S_pat=S_pat/tot
                        S_pat_err=np.sqrt(S_pat_err)
                        U_pat=U_pat/tot
                        U_pat_err=np.sqrt(U_pat_err)
                    break
        if good==0 and reduced:
            tot=0
            F_pat_err=0
            F_pat=0
            S_pat_err=0
            S_pat=0
            U_pat_err=0
            U_pat=0
            for l in range(len(dirs)):
                dups=os.listdir(data_dir+'/'+temp+'/'+dirs[l])
                for n in range(len(dups)):
                    if os.path.isdir(data_dir+'/'+temp+'/'+dirs[l]+'/'+dups[n]): 
                        try :
                            tmp=read_file(data_dir+'/'+temp+'/'+dirs[l]+'/'+dups[n]+'/_Analysis/Output.txt',silent=True)
                            F_pat_err+=float(tmp[-1][-1])**2
                            F_pat+=float(tmp[-2][-1])
                            S_pat_err+=float(tmp[-5][-1])**2
                            S_pat+=float(tmp[-6][-1])
                            U_pat_err+=float(tmp[-3][-1])**2
                            U_pat+=float(tmp[-4][-1])
                            tot+=1
                            good+=1
                        except :     
                            continue
            if good==0:
                print("Could not find free energy files for ",temp)
                return None
            else : 
                F_pat_err=np.sqrt(F_pat_err)
                F_pat=F_pat/tot       
                S_pat=S_pat/tot
                S_pat_err=np.sqrt(S_pat_err)
                U_pat=U_pat/tot
                U_pat_err=np.sqrt(U_pat_err)
        elif good==0 and not reduced :
            print("For real ?")
            print(reduced)
            print("No free energy file for "+temp+"/"+pattern)
            return None
        try : 
            tmp=read_key_file(data_dir+'/'+temp+'/'+dirs[0]+'/1/run.key',['FMCSC_PKA_REP_POT','FMCSC_TEMP'],silent=silent)
            offset_pat=float(tmp[0])
            T_pat=float(tmp[1])
        except : 
            T_pat=T
            offset_pat=0.
            print(data_dir+'/'+temp+'/'+dirs[0]+'/1/run.key is missing')
            input("This is a problem. This file is necessary to know the offset ")
    elif additive:
        T_pat=T
        F_pat=get_pattern_additive_F(pattern,T,neigh,ent_corr=ent_corr) 
        F_pat_err=0.
        F_mdcp=0.
        S_pat=0.
        S_mdcp=0.
        U_pat=F_pat
        U_mdcp=0.
        offset_pat=0.
        mdcp_offset=0.
        U_mdcp_expt=0.
        S_mdcp_expt=0.
    else : 
        T_pat=T
        F_pat=0.
        F_pat_err=0.
        F_mdcp=0.
        S_pat=0.
        S_mdcp=0.
        U_pat=0.
        U_mdcp=0.
        offset_pat=0.
        mdcp_offset=0.
        U_mdcp_expt=0.
        S_mdcp_expt=0.
    if F_pat_err>0.1:
        print("pentpeptide "+pattern+" has a large error ("+str(F_pat_err)+")")
    return F_pat,F_pat_err,F_mdcp,S_pat,S_mdcp,U_pat,U_mdcp,offset_pat,mdcp_offset,U_mdcp_expt,S_mdcp_expt,sign,F_mdcp_expt,T_pat
def get_G_sum(Garr,T):
    Garr=np.array(Garr)
    out=-R*T*np.log(np.sum(np.exp(-(Garr)/(R*T)),axis=0))
    return out 
def check_sign(AA,refs,reverse):
    for j in range(len(refs[1])):
        if refs[1][j][1].upper()==AA.upper()  :
            break
    if j==len(refs[2]):
        return 0,0
    if reverse==True :
        sign2=-refs[5][j]
    else :
        sign2=refs[5][j]
    sign=refs[5][j]
    return sign,sign2
def convert_pattern_to_simplified(pattern,neigh,central_only=True,ion_simplify=True,ion_sides_only=True,separate=[]):
    ion='EDY-HK+89'
    if ion_simplify:
        ion=ion+'R'
        ion_simp='----++++++'
    if central_only==True :
        found=False
        for j in range(len(ion)):
            if ion[j]==pattern[neigh]:
                found=True
                break
        if found==False :
            return
    pattern_out=''
    for i in range(len(pattern)):
        found_one=False
        for j in range(len(ion)):
            if ion[j]==pattern[i]:
                found_one=True
                if ion_simplify==True and (i<neigh-1 or i>neigh+1):
                    if ion[j].islower():
                        pattern_out+='0'
                    else : 
                        pattern_out+=ion_simp[j]  
                else : 
                    pattern_out+=pattern[i]
                break   
        if found_one==False:
            if ion_simplify and (i<neigh-1 or i>neigh+1) and pattern[i]!='_':
                if separate!=[]: 
                    found_sep=False
                    for m in range(len(separate)):
                        if separate[m]==pattern[i]:
                            found_sep=True
                            break
                    if found_sep: 
                        pattern_out+=pattern[i]
                    else :
                        pattern_out+='0'
                else :
                    pattern_out+='0'
            elif pattern[i]=='_' :
                pattern_out+='_'
            else :
                pattern_out+=pattern[i] 
    return pattern_out
def setup_motif_database_sequence(reduced,pattern,base_dir):
    check_and_create_rep(base_dir)
    seq_3=convert_AA_1_to_3(pattern,mode=2)
    neigh=int(len(pattern)/2)   
    if pattern[neigh]=='E':
        seq_3[neigh]='GLX'
    elif pattern[neigh]=='D':
        seq_3[neigh]='ASX'
    elif pattern[neigh]=='K':
        seq_3[neigh]='LYX'
    elif pattern[neigh]=='H':
        seq_3[neigh]='HEX'
    elif pattern[neigh]=='Y':
        seq_3[neigh]='TYX'
    W='ACE\n'
    for o in range(len(seq_3)):
        if len(seq_3[o])>0:
            W+=seq_3[o]+'\n'
    W+='NME\nEND'
    print("Creating pentapeptide database folder to be submited :")    
    print(base_dir)
    check_and_create_rep(base_dir+'/'+reduced+'/'+pattern) 
    write_file(base_dir+'/'+reduced+'/'+pattern+'/seq.in',W)
def get_pattern_additive_F(pattern,T,neigh,ent_corr=False): 
    global refs
    global AA_type
    global groups
    global R
    global DF_V,DF_Q,DU_V,DU_Q
    signs=refs[5] 
    F_pat=0.
    for a0 in range(len(refs[0])):
        if pattern[neigh]==AA_type[a0]: 
            break
    ions='EDH89KY'
    seq_F=[]
    seq_F_q=[]
    if ent_corr :
        DX_V=np.copy(DU_V)
        DX_Q=np.copy(DU_Q)
    else : 
        DX_V=np.copy(DF_V)
        DX_Q=np.copy(DF_Q)
    for a1 in range(len(AA_type)):
        if 'G'==AA_type[a1]:
            break
    F_pat+=-DX_V[a0,a1,0]*2   
    for i in range(len(pattern)): 
        for a1 in range(len(AA_type)):
            if AA_type[a1]==pattern[i].upper() and pattern[i]!='_' and i!=neigh :
                F_pat+=DX_V[a0,a1,abs(i-neigh)-1] 
                seq_F+=[DX_V[a0,a1,abs(i-neigh)-1]]
                if a1<=5 and  pattern[i].isupper():
                    F_pat+=DX_Q[a0,a1,abs(i-neigh)-1]     
                    seq_F_q+=[DX_Q[a0,a1,abs(i-neigh)-1]]
    if math.isnan(F_pat):
        print(DX_V)
        print(pattern," has a problem")
        input(F_pat) 
    return F_pat
def main_prediction(T,neigh,contexts,pat_E,pat_ste,pat_seq,map,prun_during,per_res,base_E,test_time,max_diff,silent=False):
    import itertools
    import sys
    blocks=[]
    tmp=[]
    for i in range(len(contexts)):
        tmp+=[i]
        if i%2==1:
            blocks+=[np.array(tmp)]
            tmp=[]
    dim=(len(contexts)+1,)
    for i in range(neigh):
        dim=dim+(2,)
    if not per_res:
        lvl_disc_E=np.zeros(dim,dtype=np.longdouble)
        lvl_disc_E[:]=np.longdouble('+inf')
    dim=(len(contexts)+1,len(contexts))
    for i in range(neigh):
        dim=dim+(2,)
    if per_res:
        lvl_context0=np.zeros(dim,dtype=np.longdouble)
        lvl_context0[:]=float('+inf')
        lvl_context1=np.zeros(dim,dtype=np.longdouble)
        lvl_context1[:]=float('+inf')
    else :
        lvl_ste=[np.array(['']) for i in range(len(contexts)+1)]
        lvl_E=[np.array([base_E],dtype=np.longdouble) for i in range(len(contexts)+1)]
    tot=0
    for i in range(len(pat_E)):
        if not silent :
            sys.stdout.write("\r "+str(i+1)+" out of "+str(len(pat_E))+'\n')
        temp_E0=[]
        for t in range(i+1):
            if not per_res:
                temp=np.zeros((len(lvl_ste[t])),dtype=np.longdouble)
                temp[:]=float('nan')
                for h in range(len(lvl_ste[t])):
                    break_it=False
                    for l in range(len(pat_ste[i])):
                        ind=[]
                        offset=0
                        for o in range(1,neigh+1):
                            if i-o>=0:
                                while map[i]-o-offset!=map[i-o] and neigh-o-offset>=0:
                                    offset+=1
                                if neigh-o-offset>=0:
                                    ind=[neigh-o-offset]+ind
                        min_ind=max(0,i-len(ind))
                        count_good=0
                        for o in range(len(ind)) :
                            if lvl_ste[t][h][min_ind+o]==str(pat_ste[i][l][ind[o]]):
                                count_good+=1
                        if count_good==len(ind):
                            break_it=True
                            break
                    if break_it==False:
                        print(pat_seq[i])
                        print(pat_ste[i])
                        print(lvl_ste[t])
                        input("Problem")
                    temp[h]=lvl_E[t][h]+pat_E[i][l]
                temp_E0+=[np.array(temp)]
        if not per_res :
            temp_ste1=[np.char.add(lvl_ste[t],np.array(['1'])) for t in range(i+1)]
            temp_ste0=[np.char.add(lvl_ste[t],np.array(['0'])) for t in range(i+1)]
        dim=(2,)
        for l in range(neigh-1):
            dim=dim+(2,)
        temp_pat_E=np.zeros(dim,dtype=np.longdouble)
        temp_pat_E[:]=float('+inf')
        for l in range(len(pat_ste[i])):
            all_ind=[()]
            ind=[]
            offset=0
            for o in range(1,neigh+1):
                if i-o>=0:
                    while neigh-o-offset>=0:
                        if map[i]-o-offset==map[i-o]:
                            ind=[neigh-o-offset]+ind
                            for h in range(len(all_ind)):
                                all_ind[h]=(int(pat_ste[i][l][neigh-o-offset]),)+all_ind[h]
                            break
                        else:
                            offset+=1
            true_ind=[]
            for curr in  itertools.product([0,1],repeat=neigh-len(ind)):
                ind_temp=()
                for h in range(len(ind)):
                    ind_temp+=(int(pat_ste[i][l][ind[h]]),)
                true_ind+=[curr+ind_temp]
            for h in range(len(true_ind)):
                temp_pat_E[true_ind[h]]=pat_E[i][l]
        if prun_during and not per_res :
            disc_temp_E=np.zeros(np.shape(lvl_disc_E),dtype=np.longdouble)
            disc_temp_E[:,:]=float('+inf')
        if per_res:
            lvl_temp_context0= np.zeros(np.shape(lvl_context0),dtype=np.longdouble)
            lvl_temp_context0[:,:]=float('+inf')
            lvl_temp_context1= np.zeros(np.shape(lvl_context1),dtype=np.longdouble)
            lvl_temp_context1[:,:]=float('+inf')
        for t in range(i+1):
            if per_res==True:
                if t==0:
                    curr1=()
                    for k in range(neigh):
                        curr1+=(1,)
                    curr0=curr1[:-1]+(0,)
                    lvl_context0[(t+1,i,)+curr0]=base_E+temp_pat_E[curr1]
                    lvl_context1[(t,i,)+curr1]=base_E
                for k in range(i):
                    base1=(t,k)
                    base0=(t+1,k)
                    for curr in itertools.product([0,1],repeat=neigh):
                        cont=base1+curr
                        pat_cont=curr
                        new_cont0=base0+curr[1:]+(0,)
                        new_cont1=base1+curr[1:]+(1,)
                        lvl_temp_context0[new_cont0]=get_G_sum([lvl_temp_context0[new_cont0],lvl_context0[cont]+temp_pat_E[pat_cont]],T)
                        lvl_temp_context1[new_cont0]=get_G_sum([lvl_temp_context1[new_cont0],lvl_context1[cont]+temp_pat_E[pat_cont]],T)
                        lvl_temp_context0[new_cont1]=get_G_sum([lvl_temp_context0[new_cont1],lvl_context0[cont]],T)
                        lvl_temp_context1[new_cont1]=get_G_sum([lvl_temp_context1[new_cont1],lvl_context1[cont]],T)
                k=i
                if t==0 :
                    k1=k
                    k2=k
                if t!=0 :
                    k1=k-1
                    k2=k
                base1k1=(t,k1)
                base1k2=(t,k2)
                base0k1=(t+1,k1)
                base0k2=(t+1,k2)
                for curr in itertools.product([0,1],repeat=neigh):
                    cont=base1k1+curr
                    pat_cont=curr
                    new_cont0=base0k2+curr[1:]+(0,)
                    new_cont1=base1k2+curr[1:]+(1,)
                    lvl_temp_context0[new_cont0]=get_G_sum([lvl_temp_context0[new_cont0],lvl_context0[cont]+temp_pat_E[pat_cont],lvl_context1[cont]+temp_pat_E[pat_cont]],T)
                    lvl_temp_context1[new_cont1]=get_G_sum([lvl_temp_context1[new_cont1],lvl_context1[cont],lvl_context0[cont]],T)
            if prun_during and not per_res:
                base0=(t+1,)
                base1=(t,)
                for curr in itertools.product([0,1],repeat=neigh):
                    cont=base1+curr
                    pat_cont=curr
                    new_cont0=base0+curr[1:]+(0,)
                    new_cont1=base1+curr[1:]+(1,)
                    disc_temp_E[new_cont0]=get_G_sum([disc_temp_E[new_cont0],lvl_disc_E[cont]+temp_pat_E[pat_cont]],T)
                    disc_temp_E[new_cont1]=get_G_sum([disc_temp_E[new_cont1],lvl_disc_E[cont]],T) 
        if per_res :
            lvl_context0=lvl_temp_context0
            lvl_context1=lvl_temp_context1
        if prun_during and not per_res:
            lvl_disc_E=disc_temp_E
        if per_res:
            continue
        for t in range(i+1):
            lvl_ste[t]=temp_ste1[t]
        for t in range(i+1):
            if len(lvl_ste[t+1][0])!=0:
                lvl_ste[t+1]=np.append(lvl_ste[t+1],temp_ste0[t])
                lvl_E[t+1]=np.append(lvl_E[t+1],temp_E0[t])
            else :
                lvl_ste[t+1]=temp_ste0[t]
                lvl_E[t+1]=temp_E0[t]
        for t in range(i+1):
            if prun_during and not (math.isinf(max_diff) and max_diff>0):
                if len(lvl_ste[t])<2 :
                    continue
                if lvl_ste[t][0]=='':
                    break
                W=np.exp(-(lvl_E[t])/(R*T))
                ind=np.argsort(lvl_E[t])
                if not (math.isinf(max_diff)) and (max_diff<0):
                    Z_up=np.cumsum(W[ind[::-1]])[::-1]
                    Z_down=np.cumsum(W[ind[::1]])
                    excess=np.sum(np.exp(-lvl_disc_E[t]/(R*T)))
                    G_down=-R*T*np.log(Z_down)
                    G_up=-R*T*np.log(Z_up)
                    G_up_all =-R*T*np.log(np.exp(-G_up /(R*T)) +excess)
                    G_down_all =-R*T*np.log(np.exp(-G_down /(R*T)) +excess)
                    temp=np.where(G_up_all>G_down_all+max_diff)
                    if len(temp[0])<1:  
                        continue
                    elif len(temp[0])>=len(ind):  
                        temp=[[temp[0][-1]]]
                else :
                    temp=[[1]]
                ste_temp=lvl_ste[t][ind[temp[0][0]:]]
                lvl_ste[t]=lvl_ste[t][ind[:temp[0][0]]]
                lvl_E[t]=lvl_E[t][ind[:temp[0][0]]]
                W_temp=W[ind[temp[0][0]:]]
                for curr in itertools.product([1,0],repeat=neigh):
                    temp_char=''
                    for c in range(-min(0,len(ste_temp[0])-neigh),len(curr)):
                        temp_char+=str(curr[c])
                    bool_temp=np.char.endswith(ste_temp,temp_char,len(ste_temp[0])-min(len(ste_temp[0]),neigh))
                    if bool_temp.any()==True:
                        lvl_disc_E[(t,)+curr]=-R*T*np.log(np.exp(-lvl_disc_E[(t,)+curr]/(R*T))+np.sum(W_temp[bool_temp==True]))
                        tot+=len(W_temp[bool_temp==True])
        if prun_during and t!=0 and math.isinf(get_G_sum(lvl_disc_E[t].flatten(),T)) and not (math.isinf(max_diff) and max_diff>0):
            print("MEDOC failed due to lack of machine precision. Try a 64-bit python environment.")
            quit(1)
    if per_res:
        return lvl_context0,lvl_context1
    else :
        return lvl_ste,lvl_E,lvl_disc_E
def write_file(file_name,W,silent=True):
    try :
        with open(file_name,'w') as f :
            f.writelines(W)
            f.close()
        if not silent :
            print(file_name+" written.")
    except :
        print("Could not open "+file_name)
def get_microstates_population_mesostates(DFs,DFs_err,T):
    R=1.987*10**(-3)
    W=[]
    W_err=[]    
    for i in range(len(DFs)):
        W+=[np.exp(-DFs[i]/(R*T))]
        W_err+=[(np.exp(-DFs[i]/(R*T))*abs(-DFs_err[i]/(R*T)))]
    p=[]
    p_err=[]
    W_tot_err=np.sqrt(sum([W_err[i]**2 for i in range(len(W_err))]))
    for i in range(len(DFs)):
        p+=[W[i]/sum(W)]
        p_err+=[p[-1]*np.sqrt((W_err[i]/W[i])**2+(W_tot_err/sum(W))**2)]
    return p,p_err
def check_and_create_rep(directory):
    if not os.path.exists(directory):
        os.makedirs(directory)    
        print("Created directory : "+directory)
def get_mesostate_site_spe_G(lvl_ste,lvl_E,T):
    out0=[]
    out1=[]
    for i in range(len(lvl_ste)):
        temp0=[[] for j in range(len(lvl_ste[0][0]))]
        temp1=[[] for j in range(len(lvl_ste[0][0]))]
        for j in range(len(lvl_ste[i])):
            for k in range(len(lvl_ste[i][j])):
                if lvl_ste[i][j][k]=='0':
                    temp0[k]+=[lvl_E[i][j]]
                elif lvl_ste[i][j][k]=='1':
                    temp1[k]+=[lvl_E[i][j]]
        tmp1=[]
        tmp0=[]
        for j in range(len(temp1)):
            tmp1+=[get_G_sum(temp1[j],T)]
            tmp0+=[get_G_sum(temp0[j],T)]
        out1+=[tmp1]
        out0+=[tmp0]
    out1=np.array(out1)
    out0=np.array(out0)
    return out0,out1
def plot_proba_F_per_res(save0,save1,pH,T):
    proba0=np.zeros((len(save0[0]),len(pH)),dtype=np.longdouble)
    proba1=np.zeros((len(save0[0]),len(pH)),dtype=np.longdouble)
    for k in range(len(save0[0])):
        W0=np.zeros((len(save0),len(pH)),dtype=np.longdouble)
        W1=np.zeros((len(save0),len(pH)),dtype=np.longdouble)
        for i in range(len(save0)):
            W0[i]=np.exp(-(save0[i,k]-i*np.log(10.)*R*T*pH[:])/(R*T))
            W1[i]=np.exp(-(save1[i,k]-i*np.log(10.)*R*T*pH[:])/(R*T))
        proba1[k]=np.sum(W1,axis=0)/(np.sum(W1,axis=0)+np.sum(W0,axis=0))
        proba0[k]=np.sum(W0,axis=0)/(np.sum(W1,axis=0)+np.sum(W0,axis=0))
    return proba1,proba0
def compute_charge_density(frac,charge,pH,seq,indices,suffix,win_sz=3,get_back=False):
    import matplotlib.pyplot as plt
    for i in range(len(seq)):
        if seq[i]=='R':
            charge[i]=1
    indices=np.array(indices)
    out=np.zeros((len(seq),len(pH)))
    for p in range(len(pH)):
        for r in range(len(seq)):
            temp=0.
            eff_len=0
            for n in range(max(0,r-win_sz),min(len(seq)-1,r+win_sz)+1):
                if np.any(n==indices): 
                    ind=np.argwhere(n==indices)[0]
                    if charge[n]>0 :
                        temp+=frac[ind,p]*charge[n] 
                    else : 
                        temp+=(1-frac[ind,p])*charge[n]
                else : 
                    temp+=charge[n]
                eff_len+=1.
            out[r,p]=temp/eff_len 
    seq_label=make_charge_color_string_for_plt(seq,[1 for i in range(len(seq))])
    plt.figure(figsize=(len(seq)/6,6))
    plt.imshow(out.transpose(),vmin=-1,vmax=1,cmap='bwr_r',aspect='auto',origin='lower')
    temp=[i+1 for i in range(len(seq)-2)]
    plt.xticks(temp,seq_label)
    temp=[i for i in range(0,len(pH),int(len(pH)/7))]+[len(pH)-1]
    temp2=[int(pH[i]) for i in range(0,len(pH),int(len(pH)/7))]+[14]
    plt.ylabel('pH') 
    plt.yticks(temp,temp2)
    plt.xlim(0.5,len(seq)-1.5) 
    cbar=plt.colorbar()
    cbar.set_label('Charge density',rotation=270)
    check_and_create_rep('./Results/Plots/')
    plt.tight_layout()
    plt.savefig('./Results/Plots/Charge_density_vs_pH_'+suffix+'.pdf')
    plt.close()
    if get_back :
        return out.transpose()
def make_charge_color_string_for_plt(seq_1,seq_id,include_caps=False,asString=False):
    if include_caps :
        st=0
        end=len(seq_id)
    else :
        st=1
        end=len(seq_id)-1
    seq_id_out=[]
    for k in range(st,end):
        if str(seq_id[k])=='1' :
            tmp=seq_1[k].upper()
            if seq_1[k]=='E' or seq_1[k]=='D':
                seq_id_out+=[r'{\textcolor{red}{'+tmp+'}}']
            elif seq_1[k]=='K' or seq_1[k]=='R' or seq_1[k]=='H':
                seq_id_out+=[r'{\textcolor{blue}{'+tmp+'}}']
            else : 
                seq_id_out+=[r'{\textcolor{black}{'+tmp+'}}']
        elif str(seq_id[k])=='2' :
           tmp=seq_1[k].lower()
           seq_id_out+=[r'{\textcolor{black}{\textbf{'+tmp+'}}}']
        elif seq_1[k]=='R' :
           tmp=seq_1[k].upper()
           seq_id_out+=[r'{\textcolor{blue}{'+tmp+'}}']
        else : 
            tmp=seq_1[k].upper()
            seq_id_out+=[r'{\textcolor{black}{\textbf{'+tmp+'}}}']
    if asString :
        new=''
        for i in range(len(seq_id_out)):
            new+=seq_id_out[i]
        seq_id_out=new
    return seq_id_out 
def plot_probas(Proba,Proba_err,st_count,pH,title='Proba',subrep='./',separate=0,print_micro=0,
                labely='Mesostate probability',color='rainbow',labels=[],publi_figure=False):
    import matplotlib
    from matplotlib import cm
    import matplotlib.pyplot as plt
    plt.rcParams["font.family"]="Times New Roman"
    from matplotlib.backends.backend_pgf import FigureCanvasPgf
    matplotlib.backend_bases.register_backend('pdf', FigureCanvasPgf)
    pgf_with_latex = {
        "text.usetex": True,
        "pgf.preamble":
            r'\usepackage{color}'
        ,
        "font.family": "Times New Roman"
    }
    import matplotlib
    matplotlib.rcParams.update(pgf_with_latex)
    import matplotlib.pyplot as plt
    from matplotlib import cm
    if color=='rainbow':
        colors=[cm.jet_r(float(i)/len(Proba)) for i in range(len(Proba))]
    elif type(color)==type([]):
        colors=[color[i] for i in range(len(Proba))]
    else : 
        colors=[color for i in range(len(Proba))]
    if len(labels)==0:
        labels=np.array(['' for i in range(len(Proba))])
    plt.close()
    linewidth=0.5
    if publi_figure:
        fig=plt.figure(figsize=(4.5,2.5))
    else :
        fig=plt.figure(figsize=(7.5,3.5))
    plt.xlim(0,14)
    plt.gca().set_ylim(top=1.)    
    plt.xlabel("pH")
    plt.ylabel(labely)
    for i in range(len(Proba)):
        low_err=[]
        high_err=[]
        if len(Proba_err[i])!=0:
            for p in range(len(Proba[i])):
                if math.isinf(Proba_err[i][p]):
                    low_err+=[Proba[i][p]-Proba_err[i][p]]
                    high_err+=[Proba[i][p]+Proba_err[i][p]]
                else :
                    low_err+=[Proba[i][p]]
                    high_err+=[Proba[i][p]]
        else :
            low_err+=Proba[i]
            high_err+=Proba[i]
        if len(Proba[i])==0 :
            continue
        plt.plot(pH,Proba[i],color=colors[i],linestyle='-',label=labels[i],linewidth=linewidth,alpha=0.7)
        if print_micro==1:
            for j in range(len(st_count[i])):
                plt.plot(np.array(pH),np.array(Proba[i])*st_count[i][j],color='k',linestyle='--',linewidth=0.3)        
    check_and_create_rep('Results/Plots/')
    check_and_create_rep('Results/Plots/'+subrep)
    plt.legend()
    plt.tight_layout()
    plt.savefig('Results/Plots/'+subrep+'/'+title+'.pdf')
    plt.close()
def plot_frac_and_deriv(pH_a,addi,name,points=[[],[]],points_syn=[[],[]],loc='./',prefix='',hill_param=[],fit=True,plot=True):
    import matplotlib.pyplot as plt
    import scipy 
    pH_ind_pKa=np.argwhere(abs(addi[:]-0.5)==np.amin(abs(addi[:]-0.5)))[0][0]
    pKa_a=pH_a[pH_ind_pKa]
    xd,d_addi=deriv(pH_a,addi)
    unsh=(10**(-pKa_a+pH_a))/(1+10**(-pKa_a+pH_a))
    xd,d_unsh=deriv(pH_a,unsh)
    if plot :
        plt.close()
        fig=plt.figure(1)
        fig.add_subplot(2,1,1)
    if hill_param!=[] and plot:
        y=hill_equation_from_hill_param(pH_a,hill_param)
        inds_lin=get_pH_equivalence(points[0],pH_a)
        corr=np.corrcoef(y[inds_lin[:]],points[1])
        plt.plot(pH_a,y,color='r',alpha=0.5,label='Hill fit (Payliss et al.) (r$^2$='+str(np.round(corr[0][1]**2,5))+')')
    height_u=np.amax(d_unsh)
    height_a=np.amax(d_addi)
    cross_height=0.0
    conf1=0.01
    conf2=1-conf1
    cross_m_ind=np.argwhere(abs(addi[:]-conf1)==np.amin(abs(addi[:]-conf1)))[0][0]
    cross_p_ind=np.argwhere(abs(addi[:]-conf2)==np.amin(abs(addi[:]-conf2)))[0][0]
    median_trans_ind=int(np.round((cross_p_ind+cross_m_ind)/2.,0))
    w_d=2. 
    for p in range(len(xd)):
        if xd[p]<pKa_a-w_d:
            min_ind=p+1 
            continue
        elif xd[p]>pKa_a+w_d:
            max_ind=p     
            break
    try :
        mean,std,asy=get_skewness(xd[min_ind:max_ind],d_addi[min_ind:max_ind])
    except :
        print("Could not compute skewdness. Try incresing the pH range.")
        exit(1)
    coop=height_a/height_u
    W_title=name+'\nCooperativity factor : '+str(np.round(coop,2))+'\nAsymmetry : '+str(np.round(asy,3))
    arg_addi=np.argwhere(d_addi==np.amax(abs(d_addi)))[0][0]
    if len(points[0])>0:
        inds_lin=get_pH_equivalence(points[0],pH_a)  
        corr=np.corrcoef(addi[inds_lin[:]],points[1])
    else : 
        corr=np.zeros((2,2))*np.longdouble('NaN')
    if plot :
        plt.title(W_title)
        plt.subplot(211)
        if fit:
            plt.plot(pH_a,addi,color='g',label='Fit (r$^2$='+str(np.round(corr[0][1]**2,5))+')')
        else :
            plt.plot(pH_a,addi,color='g',label='Prediction')
        if len(points_syn[0])!=0:
            plt.scatter(points_syn[0],points_syn[1],color='None',edgecolors='grey',label='Synthetic points')
        if len(points[0])!=0:
            plt.scatter(points[0],points[1],color='k',label='Real points')
        plt.xlim(0,14)
        plt.ylabel('Fraction deprotonated')
        plt.legend()
        plt.subplot(212)
        plt.xlim(0,14)
        plt.xlabel('pH')
        plt.ylabel('Fraction deprotonated\nfirst derivative')
        if len(points[0])>0:
            d_points_pH,d_points=deriv(points[0],points[1])
            plt.scatter(d_points_pH,d_points,color='k')
        if hill_param!=[]:
            xd,dy=deriv(pH_a,y)
            plt.plot(xd,dy,color='r',alpha=0.5)
        plt.vlines(pKa_a,0,d_addi[pH_ind_pKa],color='orange',linestyle='--',label='pK$_a$')
        plt.plot(xd,d_addi,color='g')
        plt.legend()
        plt.savefig(loc+prefix+'Fraction_protonated_derivative_'+name+'.pdf')
        plt.close()
    return pKa_a,coop,asy
def get_sym(pH,proba,pKa_ind):
    sym1=proba.copy()
    sym2=proba.copy()
    for p in range(len(proba)):   
        if 2*pKa_ind-p<0:
            sym1[p]=0.
            sym2[p]=0.
            continue
        elif  2*pKa_ind-p>=len(proba):
            sym1[p]=1.
            sym2[p]=1.
            continue
        if p>pKa_ind:  
            sym1[p]=1-proba[2*pKa_ind-p]
        elif p<pKa_ind:
            sym2[p]=1-proba[2*pKa_ind-p]
def deriv(x,y):                                                                                                                                                          
    return (x[1:]+x[0:-1])/2.,(y[1:]-y[0:-1])/(x[1:]-x[0:-1])
def hill_equation(pH,pKa,n,plat1,plat2): 
    y=(10**(n*(pH-pKa)))/(1.+10**(n*(pH-pKa)))*(plat2-plat1)+plat1
    return y
def hill_equation_from_hill_param(pH,hill_param):
    return hill_equation(pH,hill_param[0],hill_param[1],hill_param[2],hill_param[3])
def get_pH_equivalence(pH_dis,pH_lin):
    inds=np.zeros((len(pH_dis)),dtype=np.int)
    for i in range(len(pH_dis)):
        inds[i]=np.argwhere(np.amin(abs(pH_dis[i]-pH_lin[:]))==abs(pH_dis[i]-pH_lin[:]))[0][0]
    return inds
def get_skewness(x,y):
    N=np.sum(y)
    mean=np.sum(x*y)/N
    p=y/N
    std=np.sqrt((np.sum(p*(x-mean)**2)))
    mu3=np.sum(p*((x-mean)/(std))**3)    
    return mean,std,mu3
def mix_probas_fitting(Proba_meso,Proba,pH):
    proba_out=np.zeros((len(Proba[0]),len(pH)))
    for r in range(len(Proba[0])):
        for i in range(len(Proba_meso)):
            proba_out[r]+=Proba_meso[i]*Proba[i,r]
    proba_out=1.-proba_out                                                      
    return proba_out 
def get_mesostate_Fs(Fs,T):
    F_meso=[]
    for i in range(len(Fs)):
        offset=0
        temp=0 
        if np.mean(Fs[i])<-306. or np.mean(Fs[i])>306.:
            offset=np.mean(Fs[i])
        for j in range(len(Fs[i])):
            temp+=np.exp(-(Fs[i][j]-offset)/(R*T))
        F_meso+=[-R*T*np.log(temp)+offset]
    return F_meso
def get_probas_2(Fs,Fs_err,pH,T,ign_norm_err=True,unsafe=0):
    Fs=np.array(Fs)
    Fs_err=np.array(Fs_err)
    Weights_count=np.array([ len(Fs)-k-1 for k in range(len(Fs))])
    Weights=np.zeros((len(Fs),len(pH)),dtype=np.longdouble)
    Weights_err=np.zeros((len(Fs),len(pH)),dtype=np.longdouble)
    Weights_norm=np.zeros((len(pH)),dtype=np.longdouble)
    Weights_norm_err=np.zeros((len(pH)),dtype=np.longdouble)
    MIN=np.amin(Fs)
    MAX=np.amax(Fs)
    Exponents=np.zeros((len(Fs),len(pH)),dtype=np.longdouble)
    Exponents2=np.zeros((len(Fs),len(pH)),dtype=np.longdouble)
    Exponents3=np.zeros((len(Fs),len(pH)),dtype=np.longdouble)
    Fs=np.asarray(Fs)
    Proba=np.zeros((len(Fs),len(pH)))
    Proba_err=np.zeros((len(Fs),len(pH)))
    for i in range(len(Fs)):
        if math.isnan(Fs[i]):
            continue
        Exponents[i,:]=(-Fs[i]+np.log(10.)*R*T*pH[:]*Weights_count[i])/(R*T)
        Exponents2[i,:]=(np.log(10.)*R*T*pH[:]*Weights_count[i])/(R*T)
        Exponents3[i,:]=-Fs[i]
    for i in range(len(Fs)):
        Weights[i,:]=np.exp(Exponents[i,:])
    Weights_norm[:]=np.sum(Weights[:,:],axis=0)
    for i in range(len(Fs)): 
        if math.isnan(Fs[i]):
            if unsafe==1 :
                Proba[i]+=np.zeros((len(pH)))
            continue
        for p in range(len(pH)):
            Proba[i,p]=Weights[i,p]/Weights_norm[p]        
            if ign_norm_err==False :
                if p>0 and p<len(pH)-1 :
                    cor=np.corrcoef([Weights[i,p-1:p+1],Weights_norm[p-1:p+1]])
                else :
                    cor=np.zeros(((2,2)),dtype=float)
                A=Weights_norm[p]
                S_A=Weights_norm_err[p]
                B=Weights[i,p]
                S_B=Weights_err[i,p]
                if math.isnan(cor[0][1])==True :
                    cor[0][1]=0.0
                if S_A==float('inf') or S_B==float('inf') or A==0.0 or B==0.0:
                    Proba_err[i]+=[0.0]
                else:
                    Proba_err[i]+=[abs(Proba[i,p])*\
                    np.sqrt((S_A/A)**2+(S_B/B)**2-2*cor[0][1]*S_A*S_B/(A*B))]
            else :
                Proba_err[i]+=[Weights_err[i,p]/Weights_norm[p]]
    for i in range(len(Fs)):
        if math.isnan(Fs[i]):
            continue
        Weights_err[i,:]=abs(((Fs_err[i])/(R*T)))*np.exp((-Fs[i]+np.log(10.)*R*T*pH[:]*Weights_count[i])/(R*T))
        Weights_norm[:]+=np.exp((-Fs[i]+np.log(10.)*R*T*pH[:]*Weights_count[i])/(R*T))
        if ign_norm_err==False :
            for p in range(len(pH)):
                if p>0 and p<len(pH)-1 :
                    cor=np.corrcoef([Weights_norm[p-1:p+1],Weights[i,p-1:p+1]])
                else :
                    cor=np.zeros(((2,2)),dtype=float)
                if math.isnan(cor[0][1])==True :
                    cor[0][1]=0.0
                if math.isnan(Fs_err[i])==False :
                    if Weights_norm_err[p]!=0:
                        Weights_norm_err[p]+=np.sqrt((Weights_norm_err[p])**2+(Weights_err[i,p])**2)
                    else :
                        Weights_norm_err[p]+=Weights_err[i,p]
    return Weights_norm,Weights_norm_err,Proba,Proba_err
def plot_probas2(Proba,Proba_err,st_count,pH,title='Proba',subrep='./',legend=[]):
    import matplotlib
    from matplotlib import cm
    import matplotlib.pyplot as plt
    plt.rcParams["font.family"]="Times New Roman"
    from matplotlib.backends.backend_pgf import FigureCanvasPgf
    matplotlib.backend_bases.register_backend('pdf', FigureCanvasPgf)
    pgf_with_latex = {
        "text.usetex": True,
        "pgf.preamble":
            r'\usepackage{color}'
        ,
        "font.family": "Times New Roman"}
    import matplotlib
    matplotlib.rcParams.update(pgf_with_latex)
    import matplotlib.pyplot as plt
    from matplotlib import cm
    colors=[cm.gnuplot(float(i)/len(Proba)) for i in range(len(Proba))] 
    fig=plt.figure(figsize=(7,3))
    ax1=fig.add_axes([0.08,0.15,0.8,0.80])
    plt.xlim(np.round(np.amin(pH)),np.round(np.amax(pH)))
    plt.gca().set_ylim(top=1.)    
    pH=np.array(pH)
    if len(legend)==0:
        legend=['' for i in range(len(Proba))]
    plt.xlabel("pH")
    plt.ylabel("Mesostate probability")
    for i in range(len(Proba)):
        low_err=[]
        high_err=[]
        if len(Proba_err[i])!=0:
            for p in range(len(Proba[i])):
                if math.isinf(Proba_err[i][p]):
                    low_err+=[Proba[i][p]-Proba_err[i][p]]
                    high_err+=[Proba[i][p]+Proba_err[i][p]]
                else :
                    low_err+=[Proba[i][p]]
                    high_err+=[Proba[i][p]]
        else :
            low_err+=Proba[i]
            high_err+=Proba[i]
        if len(Proba[i])==0 :
            continue
        plt.plot(pH,Proba[i],color=colors[i],linestyle='-',label=str(legend[i]))
        plt.fill_between(pH, low_err, high_err, color=colors[i],alpha=0.5)
    plt.legend()
    check_and_create_rep('Results/Plots/')
    check_and_create_rep('Results/Plots/'+subrep)
    plt.savefig('Results/Plots/'+subrep+'/Mesostates_'+title+'.pdf')
def write_per_res_F(save0,save1,suffix):
    check_and_create_rep('Results/Fs/')
    W=''                                                                                                                                                                  
    for i in range(len(save0)):
        for j in range(len(save0[i])):
            W+=str(save0[i][j])+'\t'
        W+='\n'
    write_file('Results/Fs/Per_res_0_'+suffix+'.txt',W)
    W=''
    for i in range(len(save1)):
        for j in range(len(save1[i])):
            W+=str(save1[i][j])+'\t'
        W+='\n'
    write_file('Results/Fs/Per_res_1_'+suffix+'.txt',W)
def plot_quantity_vs_pH2(vals,Proba_1,pH,seq_1,st_count,name,publi_figure=False,labely=''):
    import matplotlib 
    matplotlib.use("pgf")
    from matplotlib.backends.backend_pgf import FigureCanvasPgf 
    matplotlib.backend_bases.register_backend('pdf', FigureCanvasPgf)
    pgf_with_latex = {
        "text.usetex": True,
        "pgf.preamble":
            r'\usepackage{color}'
        ,
        "font.family": "Times New Roman"
    }
    import matplotlib
    matplotlib.rcParams.update(pgf_with_latex)
    import matplotlib.pyplot as plt    
    from matplotlib import cm
    plt.close()
    if publi_figure:
        plt.figure(figsize=(4,3))
    else :
        plt.figure(figsize=(8,6))
    Values=np.zeros((len(pH)),dtype=float)      
    Values=np.transpose(Values)
    SSP=np.asarray(vals) 
    for i in range(len(st_count)):     
        for j in range(len(st_count[i])):
            if math.isnan(st_count[i][j]*SSP[i][j])==False:           
                Values[:]=Values[:]+Proba_1[i]*st_count[i][j]*SSP[i][j]
    plt.xlim(0,14)
    plt.ylim(np.min(Values)-0.5,np.max(Values)+0.5)
    plt.ylabel(labely)
    plt.xlabel('pH')
    plt.plot(pH,Values)
    plt.tight_layout()
    plt.savefig('Results/Plots/'+name+'_vs_pH.pdf')
    plt.close()
    save_pH_dependent_curve(Values,pH,name)   
def save_pH_dependent_curve(vals,pH,name):
    W='pH\t'+name+'\n'
    for p in range(len(pH)):
        W+=str(pH[p])+'\t'+str(vals[p])+'\n'
    check_and_create_rep('./Results/Plots/pH_plots_raw_data')
    write_file('./Results/Plots/pH_plots_raw_data/'+name+'.txt',W)
import matplotlib
import time
matplotlib.use("pgf")                                                                    
from matplotlib.backends.backend_pgf import FigureCanvasPgf 
matplotlib.backend_bases.register_backend('pdf', FigureCanvasPgf)
pgf_with_latex = {
    "text.usetex": True,
    "pgf.preamble":
        r'\usepackage{color}',
    "font.family": "Times New Roman" }
import matplotlib
matplotlib.rcParams.update(pgf_with_latex)
import matplotlib.pyplot as plt
from matplotlib import cm
import numpy as np
import scipy.misc
import math
import os
global AA_type
MODULE_PATH = os.path.dirname(__file__)
AA_type=['E','D','H','K','Y','8','9','R','C','A','F','G','L','I','M','N','P','Q','T','V','S','W']
default_res=0.01
R=np.longdouble(1.98720425864083*10**(-3))
if __name__=="__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--site_specific","-ss",
                        help="Whether the scope of the prediction is global (0) or site-specific (1)",
                        default=0)
    parser.add_argument("--seq_file","-s",
                        help="Sequence file containing a single line of uninterrupted amino acid sequence",
                        default='seq.fasta')
    parser.add_argument("--predict_type", "-pt",
                        help="Prediction type ([I]mplicit, [U]nshifted)",
                        default="I")
    parser.add_argument("--pH_range","-pH",nargs=2,default=[0,14])
    parser.add_argument("--nneigh", "-nn",
                        help="Number of immediate neighbors (on one side) for peptides",default=2)
    parser.add_argument("--plot_res", "-pr",
                        help="Plot resolution",
                        default=default_res)
    parser.add_argument("--det_level", "-dl",
                        help="Level of details for output ",
                        default=2)
    parser.add_argument("--temp", "-t",
                        help="Temperature ",
                        default=298.)
    args = parser.parse_args()
    if args.pH_range :
        if len(args.pH_range)!=2:
            print("Must provide 2 values for the pH range")
            exit()
        else :
            pH_range=[float(args.pH_range[0]),float(args.pH_range[1])]
    else :
        pH_range=[0,14]
    if args.seq_file:
        seq_file=args.seq_file
    if args.site_specific:
        try:
            if int(args.site_specific)==1:
                per_res=True
            elif int(args.site_specific)==0:
                per_res=False
            else :
                per_res=False
                print("Invalid option for site_specific, defaulting to ",per_res)
        except :
            per_res=False
            print("Invalid option for site_specific, defaulting to ",per_res)
    else :
        per_res=False
    if args.temp:
        try: 
            T=np.longdouble(args.temp)
        except :
            T=np.longdouble(298.)
            print("Invalid option for temperature, defaulting to ",T)
    if args.det_level:
        try: 
            det_lvl=int(args.det_level)
        except :
            det_lvl=2
            print("Invalid option for det_level, defaulting to ",det_lvl)
    if args.plot_res:
        try: 
            res=float(args.plot_res)
        except : 
            res=default_res
            print("Invalid option for plot res, defaulting to ",res)
    else : 
        res=default_res
    if args.predict_type :
        if args.predict_type.upper()=='I' :
            additive=True
            penta=False 
            unshifted=False
            suffix='Implicit'
        elif args.predict_type.upper()=='U' :
            additive=False
            penta=False
            unshifted=True
            suffix='Unshifted'
        else :
            print("Invalid option for predict type, aborting")
            quit()
    else : 
        additive=False
        penta=True
        unshifted=False
    prun_during=True
    prun_after=False
    if args.nneigh :
        try : 
            if int(args.nneigh)>=1:
                neigh=int(args.nneigh)
            else :
                neigh=2
                print("Invalid value for nneigh, defaulting to ",neigh)
        except : 
            neigh=2
            print("Invalid value for nneigh, defaulting to ",neigh)
    fraction_kept=0.
    max_frac=float('+inf')
    test_time=True
    publi_figure=True
    reduced=False
    test=''
    recal=''
    HT=True
    debug=False
    reverse=True
    base_E=-709.0*(R*T)
    if HT==True :
        database_suffix='_HT'     
    else : 
        database_suffix=''
    base_rep=''
    initialize_additive_DF_array_MEDOC_public()
    pH=np.arange(pH_range[0],pH_range[1],res,dtype=np.longdouble)
    seq_1=read_file(seq_file)[0][0]
    if seq_1[0]!='z':
        seq_1='z'+seq_1
    if seq_1[-1]!='z':
        seq_1=seq_1+'z'
    seq_3=convert_AA_1_to_3(seq_1,mode=2)
    list_res=[i for i in range(len(seq_3))]
    T_expt=298.
    seq_1=convert_AA_3_to_1_letter(seq_3)
    max_diff=-R*T*np.log(max_frac)
    t_start=time.time()
    sites_num,titrable_residue_indexes,pos_res,neg_res,base_charge,arg_res,raw_seq,seq_data_q,seq_data_id,seq_id_reduced,map,new_W=read_sequence(seq_3,list_res)
    Nmes=pos_res+base_charge+1-(-neg_res+arg_res+base_charge)
    layers_q=np.array([i for i in range(-neg_res+arg_res+base_charge,pos_res+base_charge+1)])
    refs=get_ref_pkas_MEDOC_public()
    contexts,states=get_base_contexts(map,neigh,seq_1,seq_data_q)
    pat_E,pat_ste,pat_seq=get_all_contexts(contexts,states,neigh,refs,unshifted,reverse,penta,additive,T,base_rep,
                                              reduced)
    if per_res :
        lvl_context0,lvl_context1=main_prediction(T,neigh,contexts,pat_E,pat_ste,pat_seq,map,prun_during,per_res,
                                                     base_E,test_time,max_diff)
    else :
        lvl_ste,lvl_E,lvl_disc_E=main_prediction(T,neigh,contexts,pat_E,pat_ste,pat_seq,map,prun_during,per_res,
                                                    base_E,test_time,max_diff)
    disc_E=[]
    print("There are ",pos_res-arg_res+neg_res," ionizable residue")
    if test_time :
        print("MEDOC ran in "+str(time.time()-t_start)+" seconds")
        write_file('./Compute_time.txt',str(time.time()-t_start))
    if not per_res:
        SUM=[]
        for i in range(Nmes):
            SUM+=[len(lvl_ste[i])]
    if (prun_during or prun_after) and not per_res:
        if fraction_kept==1. :
            SW=''
            EW=''
            popW=''
            for i in range(len(lvl_ste)):
                for j in range(len(lvl_ste[i])):
                    SW+=lvl_ste[i][j]+'\t'
                    EW+=str(lvl_E[i][j])+'\t'
                SW+='\n'
                EW+='\n'
                temp=get_microstates_population_mesostates(lvl_E[i],lvl_E[i]*0,T)
                for j in range(len(temp[0])):
                    popW+=str(temp[0][j])+'\t'
                popW+='\n'
            print('./Results/Fs/Fs_'+suffix+'.txt')
            write_file('./Results/Fs/Populations_'+suffix+'.txt',popW)
            check_and_create_rep('./Results/States_details/')
            write_file('./Results/States_details/States_'+suffix+'.txt',SW)
            write_file('./Results/Fs/Fs_'+suffix+'.txt',EW)
    Meso_G_all=np.zeros((Nmes),dtype=np.longdouble)
    if prun_during and not per_res:
        if det_lvl>=2: 
            print("q\tTotal energy\tKept energy\tDiscarded energy")
        for i in range(len(lvl_disc_E)):
            temp_1=get_G_sum(np.concatenate((lvl_disc_E[i].flatten(),lvl_E[i])),T)
            temp_2=get_G_sum(lvl_E[i],T)
            temp_3=get_G_sum(lvl_disc_E[i].flatten(),T)
            if det_lvl>=2:
                print(layers_q[len(layers_q)-1-i],'\t',"%0.4f" % temp_1,'\t',"%0.4f" % temp_2,'\t',"%0.4f" % temp_3)
    elif not per_res :
        if det_lvl>=2:
            print("Total energy\tKept energy\tDiscarded energy")
        for i in range(Nmes): 
            temp_1=get_G_sum(lvl_E[i],T)
            temp_2=disc_E[i] 
            temp_3=get_G_sum([temp_1,temp_2],T)
            if det_lvl>=2:
                print(temp_3,temp_1,temp_2)
    check_and_create_rep('Results/Fs')
    if per_res:
        if debug==True:
            reconstructed=np.zeros((2,)+np.shape(lvl_context0))
            reconstructed[:,:,:]=float('+inf')
            for i in range(Nmes):
                for j in range(len(lvl_ste[i])):
                    ind=()        
                    for k in range(len(lvl_ste[i][j])):
                        if lvl_ste[i][j][k]=='0':
                            base=(0,i,k)
                        else :
                            base=(1,i,k)
                        for l in range(len(lvl_ste[i][j])-neigh,len(lvl_ste[i][j])):
                            base+=(int(lvl_ste[i][j][l]),)
                        ind+=(base,)
                    for k in range(len(ind)):             
                        reconstructed[ind[k]]=get_G_sum([reconstructed[ind[k]],lvl_E[i][j]],T)
                if det_lvl>=3 :                
                    for k in range(len(reconstructed[0][i])):
                        print(i,k)
                        print("0should be ")
                        print(reconstructed[0][i][k])
                        print("0is ")
                        print(lvl_context0[i][k])
                        print()
            out0,out1=get_mesostate_site_spe_G(lvl_ste,lvl_E,T)
        save0=np.zeros((Nmes,len(lvl_context0[0])))
        save1=np.zeros((Nmes,len(lvl_context0[0])))
        for i in range(Nmes):
            for k in range(len(lvl_context0[0])):
                save0[i,k]=get_G_sum(lvl_context0[i,k].flatten(),T)
                save1[i,k]=get_G_sum(lvl_context1[i,k].flatten(),T)
        save0_tmp=save0
        save1_tmp=save1
        print("Computing residue wise probabilities")
        proba0,proba1=plot_proba_F_per_res(save0-2*base_E,save1-2*base_E,pH,T)
        if det_lvl>=1:
            print("Plotting charge density vs pH")
            compute_charge_density(proba0,seq_data_q,pH,seq_1,map,suffix)
        print("Plotting residue wise probabilities")
        IAAs=['D','E','Y','H','K']
        colors=['orange','red','maroon','darkturquoise','blue']
        st_count_fake_r=[[1.] for i in range(len(proba0))]
        temp_all=[]
        temp_temp=[]
        colors_all=[]
        all_colors_all=[]
        all_labels=[]
        all_labels_all=[]
        used=np.zeros(np.shape(IAAs))
        for t in range(len(IAAs)):
            temp=[]
            temp_labels=[]
            temp_colors=[]
            for i in range(len(proba0)):
                if seq_1[map[i]]==IAAs[t]:
                    temp+=[proba0[i]]
                    temp_all+=[proba0[i]]
                    colors_all+=[colors[t]]
                    temp_colors+=[colors[t]]
                    if used[t]==0:
                        used[t]=1
                        temp_labels+=[IAAs[t]]
                        all_labels+=[IAAs[t]]
                    else :
                        all_labels+=['_'+IAAs[t]]
                        temp_labels+=['_'+IAAs[t]]
            temp_temp+=[temp]
            all_labels_all+=[temp_labels]
            all_colors_all+=[temp_colors]
        if det_lvl>=2:
            try :
                print("Plotting all residue probabilities")
                plot_probas(np.array(temp_all),np.array(temp_all)*0.,st_count_fake_r,pH,
                           title='Proba_Residue_all_'+suffix,labely='Fraction protonated',
                           color=colors_all,labels=np.array(all_labels),publi_figure=publi_figure)
            except :
                print('Could not plot all probas at once')
        if det_lvl>=3:
            for t in range(len(IAAs)):
                if len(temp_temp[t])==0:
                    continue
                try :
                    print("Plotting all "+IAAs[t]+" probabilities")
                    plot_probas(np.array(temp_temp[t]),np.array(temp_temp[t])*0.,st_count_fake_r,pH,
                                   title='Proba_Residue_all_'+IAAs[t]+'_'+suffix,labely='Fraction protonated',
                                   color=all_colors_all[t],labels=all_labels_all[t],publi_figure=publi_figure)
                except :
                    print("Could not plot probas for "+IAAs[t])
    if det_lvl>=2 and per_res:
        print("Printing site specific derivative and transition parameters")
        param_all=np.zeros((len(proba0),3),dtype=np.longdouble)
        names=[]
        for i in range (len(proba0)):
            names+=[seq_1[map[i]]+str(map[i]+1)]
            try :
                if det_lvl<4 :
                    param_all[i]=plot_frac_and_deriv(pH,proba1[i,:],name=seq_1[map[i]]+str(map[i]+1),loc='./Results/Plots/',fit=False,plot=False)
                else :
                    param_all[i]=plot_frac_and_deriv(pH,proba1[i,:],name=seq_1[map[i]]+str(map[i]+1),
                                                        loc='./Results/Plots/',fit=False,plot=True)
            except :
                print("Could not print individual figure for ",names[i])
        x=[i for i in range(len(param_all))]
        plt.bar(x,param_all[:,1],color='orange')
        plt.xticks(x,names,rotation=90)
        plt.savefig('Results/Plots/Cooperativity_factor_per_res_pred.pdf')
        plt.close()
        W=''
        for i in range(len(names[i])):
            W+=names[i]+'\t'+str(param_all[i,1])+'\n'
        write_file('./Results/Plots/pH_plots_raw_data/Cooperativity_factor_per_res.txt',W)
        plt.bar(x,param_all[:,2],color='green')
        plt.xticks(x,names,rotation=90)
        plt.savefig('Results/Plots/Asymetry_factor_per_res_pred.pdf')
        plt.close()
        W=''
        for i in range(len(names[i])):
            W+=names[i]+'\t'+str(param_all[i,2])+'\n'
        write_file('./Results/Plots/pH_plots_raw_data/Asymetry_factor_per_res.txt',W)
    if per_res:
        W='pH\t'
        for i in range(len(temp_all)):
            W+='res_'+str(map[i])+'\t'
        W+='\n'
        for p in range(len(pH)):
            W+=str(pH[p])+'\t'
            for r in range(len(temp_all)):
                W+=str(temp_all[r][p])+'\t'
            W+='\n'
        check_and_create_rep('./Results/Plots/pH_plots_raw_data/')
        write_file('./Results/Plots/pH_plots_raw_data/Fraction_protonated_per_residue_'+suffix+'.txt',W)
        W=''
        pKas_out=[]
        pKas_ind=[]
        for i in range(len(proba0)):
            for p in range(1,len(proba0[i])):
                if proba0[i][p]<0.5  and proba0[i][p-1]>=0.5 :
                    pKas_out+=[pH[p]]
                    pKas_ind+=[p]
                    W+=seq_1[map[i]]+str(map[i])+'\t'+str(np.round(pH[p],len(str(res))-1))+'\n'
                    break
                elif p==len(proba0[i])-1:
                    pKas_out+=[float('NaN')]
                    pKas_ind+=[p]
                    W+=seq_1[map[i]]+str(map[i])+'\t'+str('NaN')+'\n'
        check_and_create_rep('Results/pKas/')
        write_file('Results/pKas/pKas_per_res_'+suffix+'.txt',W)
    pop_count=[[1.] for i in range(Nmes)]
    qs=[[layers_q[i]] for i in range(len(layers_q))]
    if det_lvl>=5 and max_frac==0.0:
        F_meso=get_mesostate_Fs(lvl_E,T) 
        print("Computing weights restricted")
        Weights_norm,Weights_norm_err,Proba_meso,Proba_meso_err=get_probas_2(F_meso,F_meso,pH,T)
        print("Plotting probas restricted")
        plot_probas2(Proba_meso,Proba_meso_err,pop_count,pH,subrep='',title='Proba_restricted_'+suffix)
    if per_res :
        for i in range(Nmes):
            Meso_G_all[i]=get_G_sum([get_G_sum(lvl_context0[i,0].flatten(),T),get_G_sum(lvl_context1[i,0].flatten(),T)],T)
        write_per_res_F(save0,save1,suffix)
    else :
        for i in range(Nmes):
            Meso_G_all[i]=get_G_sum(np.concatenate((lvl_disc_E[i].flatten(),lvl_E[i])),T)
    Meso_G_all=Meso_G_all[::-1]-2*base_E  
    W=''
    for i in range(len(Meso_G_all)):
        W+=str(Meso_G_all[i])+'\n'
    check_and_create_rep('Results/Fs')
    write_file('Results/Fs/Mesostate_F_'+suffix+'.txt',W,silent=False)
    if det_lvl>=1:
        print("Computing weights")
        Weights_norm,Weights_norm_err,Proba_meso,Proba_meso_err=get_probas_2(Meso_G_all,Meso_G_all*0.,pH,T)
    if det_lvl>=2:
        print("Plotting mesostate probas")
        plot_probas2(Proba_meso,Proba_meso_err,pop_count,pH,subrep='',title='Proba_all_'+suffix,legend=layers_q)
    if det_lvl>=1:
        print("Plotting the charge profile")
        check_and_create_rep('Results/Plots')
        plot_quantity_vs_pH2(qs,Proba_meso,pH,seq_1,pop_count,'Net_charge_'+suffix,publi_figure=publi_figure,labely='Net charge')
